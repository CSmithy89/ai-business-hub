<?xml version="1.0" encoding="UTF-8"?>
<story-context>
  <story-info>
    <id>06-1</id>
    <title>Implement Credential Encryption</title>
    <status>ready-for-dev</status>
    <epic>EPIC-06 - BYOAI Configuration</epic>
    <points>2</points>
    <priority>P0 (Critical)</priority>
  </story-info>

  <requirements>
    <summary>
      Create a secure credential encryption service for storing AI provider API keys at rest in the database.
      Uses Node.js built-in crypto module with AES-256-GCM authenticated encryption (AEAD) providing both
      confidentiality and integrity guarantees without external dependencies.
    </summary>

    <acceptance-criteria>
      <criterion id="AC1">CredentialEncryptionService class created in packages/shared/src/utils/encryption.ts</criterion>
      <criterion id="AC2">Service successfully encrypts plaintext API keys using AES-256-GCM algorithm</criterion>
      <criterion id="AC3">Service successfully decrypts encrypted API keys back to plaintext</criterion>
      <criterion id="AC4">Master encryption key loaded from ENCRYPTION_MASTER_KEY environment variable</criterion>
      <criterion id="AC5">Service throws descriptive error if master key is missing or invalid length</criterion>
      <criterion id="AC6">Each encrypted value uses a unique randomly-generated salt</criterion>
      <criterion id="AC7">Encrypted output format includes: salt + IV + authTag + encryptedData (base64-encoded)</criterion>
      <criterion id="AC8">Unit tests achieve &gt;95% code coverage</criterion>
      <criterion id="AC9">Documentation added to .env.example for key generation</criterion>
      <criterion id="AC10">README or inline comments document the encryption format and security properties</criterion>
    </acceptance-criteria>

    <technical-specifications>
      <algorithm>
        <name>AES-256-GCM</name>
        <description>Galois/Counter Mode - NIST-approved authenticated encryption (AEAD)</description>
        <module>Node.js built-in crypto module</module>
      </algorithm>

      <key-derivation>
        <algorithm>PBKDF2</algorithm>
        <iterations>100000</iterations>
        <hash-function>SHA-256</hash-function>
        <salt-size>64 bytes (unique per encrypted value)</salt-size>
        <derived-key-size>32 bytes</derived-key-size>
      </key-derivation>

      <data-format>
        <description>Base64-encoded buffer containing: salt (64 bytes) + IV (16 bytes) + authTag (16 bytes) + encryptedData (variable)</description>
        <total-overhead>96 bytes + variable encrypted data length</total-overhead>
      </data-format>

      <constants>
        <constant name="ALGORITHM">aes-256-gcm</constant>
        <constant name="IV_LENGTH">16 bytes</constant>
        <constant name="AUTH_TAG_LENGTH">16 bytes</constant>
        <constant name="SALT_LENGTH">64 bytes</constant>
        <constant name="KEY_LENGTH">32 bytes</constant>
      </constants>

      <environment-variables>
        <variable name="ENCRYPTION_MASTER_KEY" required="true">
          <description>Base64-encoded 32-byte master encryption key</description>
          <generation-command>node -e "console.log(require('crypto').randomBytes(32).toString('base64'))"</generation-command>
        </variable>
      </environment-variables>
    </technical-specifications>

    <security-considerations>
      <consideration type="master-key-storage">
        Never commit master key to version control. Store in environment variables only.
        Use secret management in production (AWS Secrets Manager, etc.)
      </consideration>
      <consideration type="salt-uniqueness">
        Generate new random salt for each encryption operation. Prevents rainbow table attacks.
        Salt is stored with encrypted data (not secret).
      </consideration>
      <consideration type="authentication-tag">
        Prevents tampering with encrypted data. Validated during decryption.
        Decryption fails if data modified.
      </consideration>
      <consideration type="key-rotation">
        Architecture supports future key versioning (post-MVP enhancement)
      </consideration>
    </security-considerations>
  </requirements>

  <technical-context>
    <project-structure>
      <location>
        <path>packages/shared/src/utils/encryption.ts</path>
        <description>Encryption service implementation (NEW FILE - directory needs to be created)</description>
        <status>needs-creation</status>
      </location>
      <location>
        <path>packages/shared/src/utils/encryption.test.ts</path>
        <description>Unit tests for encryption service (NEW FILE)</description>
        <status>needs-creation</status>
      </location>
      <location>
        <path>packages/shared/src/index.ts</path>
        <description>Package exports - needs to export CredentialEncryptionService</description>
        <status>needs-update</status>
      </location>
      <location>
        <path>.env.example</path>
        <description>Environment variable documentation - needs ENCRYPTION_MASTER_KEY entry</description>
        <status>needs-update</status>
        <current-content>Has ENCRYPTION_KEY (line 26) - should be renamed to ENCRYPTION_MASTER_KEY for consistency</current-content>
      </location>
    </project-structure>

    <existing-patterns>
      <service-pattern>
        <description>Project uses class-based services with clear constructor validation</description>
        <example>
          PrismaService (apps/api/src/common/services/prisma.service.ts) shows pattern:
          - Injectable decorator for NestJS
          - Constructor initialization
          - Lifecycle hooks (OnModuleInit, OnModuleDestroy)
          - Comprehensive JSDoc comments
        </example>
        <note>
          CredentialEncryptionService will be in packages/shared (not apps/api), so it won't use
          NestJS decorators. It will be a plain TypeScript class that can be instantiated anywhere.
        </note>
      </service-pattern>

      <typescript-config>
        <strict-mode>true</strict-mode>
        <target>ES2021</target>
        <module>commonjs</module>
        <features>
          - strictNullChecks: true
          - noImplicitAny: true
          - strictBindCallApply: true
          - forceConsistentCasingInFileNames: true
        </features>
      </typescript-config>

      <error-handling>
        <pattern>Throw descriptive Error objects with clear messages</pattern>
        <example>throw new Error('ENCRYPTION_MASTER_KEY environment variable is required')</example>
      </error-handling>
    </existing-patterns>

    <database-context>
      <table>
        <name>ai_provider_configs</name>
        <field name="apiKeyEncrypted" type="String" db-type="Text">
          Stores encrypted API keys. This field will use the encryption service.
        </field>
        <location>packages/db/prisma/schema.prisma (lines 174-176)</location>
      </table>
      <note>
        Database schema already exists. This story creates the encryption service that will be
        used when reading/writing the apiKeyEncrypted field in future stories (06.2, 06.3).
      </note>
    </database-context>

    <integration-points>
      <future-consumer>
        <name>AIProvidersService</name>
        <story>06.3</story>
        <usage>Encrypt API keys before database storage</usage>
      </future-consumer>
      <future-consumer>
        <name>AIProviderFactory</name>
        <story>06.2</story>
        <usage>Decrypt API keys when creating provider instances</usage>
      </future-consumer>
      <future-consumer>
        <name>BYOAIMiddleware</name>
        <story>06.9</story>
        <usage>Python equivalent for AgentOS (separate implementation)</usage>
      </future-consumer>
    </integration-points>
  </technical-context>

  <implementation-guide>
    <step number="1">
      <title>Create utils directory</title>
      <command>mkdir -p packages/shared/src/utils</command>
      <description>The utils directory does not currently exist and needs to be created</description>
    </step>

    <step number="2">
      <title>Create encryption service</title>
      <file>packages/shared/src/utils/encryption.ts</file>
      <implementation-notes>
        Reference implementation available in tech spec (lines 111-191 of tech-spec-epic-06.md).

        Class structure:
        - private readonly masterKey: Buffer (validated in constructor)
        - constructor(): validates ENCRYPTION_MASTER_KEY env var
        - encrypt(plaintext: string): string (returns base64-encoded ciphertext)
        - decrypt(ciphertext: string): string (returns plaintext)

        Encryption process:
        1. Generate random salt (64 bytes)
        2. Generate random IV (16 bytes)
        3. Derive key using PBKDF2 (masterKey + salt, 100000 iterations, SHA-256)
        4. Encrypt plaintext using AES-256-GCM with derived key and IV
        5. Extract authentication tag (16 bytes)
        6. Combine: salt + IV + authTag + encryptedData
        7. Base64 encode and return

        Decryption process:
        1. Base64 decode to buffer
        2. Extract components: salt (0-64), IV (64-80), authTag (80-96), encrypted (96+)
        3. Derive key using PBKDF2 (masterKey + salt, 100000 iterations, SHA-256)
        4. Create decipher with algorithm, key, IV
        5. Set authentication tag
        6. Decrypt and return plaintext
        7. If authTag invalid, crypto module will throw (tamper detection)
      </implementation-notes>
    </step>

    <step number="3">
      <title>Create comprehensive unit tests</title>
      <file>packages/shared/src/utils/encryption.test.ts</file>
      <test-cases>
        1. Successful encrypt/decrypt roundtrip
           - Test with various input lengths
           - Test with special characters and unicode

        2. Master key validation
           - Missing ENCRYPTION_MASTER_KEY throws error
           - Invalid base64 throws error
           - Wrong key length (not 32 bytes) throws error

        3. Salt uniqueness
           - Encrypting same plaintext twice produces different ciphertext
           - Verify extracted salt is different each time

        4. Tamper detection
           - Modifying ciphertext causes decryption to fail
           - Modifying authTag causes decryption to fail
           - Authentication tag validation works correctly

        5. Error handling
           - Invalid base64 input to decrypt
           - Truncated ciphertext (too short to extract components)
           - Wrong master key used for decryption
      </test-cases>
      <coverage-target>&gt;95%</coverage-target>
      <test-framework>Jest (existing project test framework)</test-framework>
    </step>

    <step number="4">
      <title>Export from shared package</title>
      <file>packages/shared/src/index.ts</file>
      <changes>
        Add export line:
        export { CredentialEncryptionService } from './utils/encryption';

        Or if exporting all utils:
        export * from './utils/encryption';
      </changes>
    </step>

    <step number="5">
      <title>Update .env.example</title>
      <file>.env.example</file>
      <changes>
        Line 26 currently has:
        ENCRYPTION_KEY="generate-with-openssl-rand-base64-32"

        Should be updated to:
        ENCRYPTION_MASTER_KEY="generate-with-openssl-rand-base64-32"

        Add comment above explaining:
        # Master encryption key for encrypting AI provider API keys (AES-256-GCM)
        # Generate with: node -e "console.log(require('crypto').randomBytes(32).toString('base64'))"
      </changes>
    </step>

    <step number="6">
      <title>Run tests and verify coverage</title>
      <commands>
        <command>cd packages/shared &amp;&amp; npm test encryption.test.ts</command>
        <command>cd packages/shared &amp;&amp; npm run test:coverage</command>
      </commands>
      <success-criteria>
        - All tests pass
        - Coverage &gt;95% for encryption.ts
        - No TypeScript errors
        - No ESLint warnings
      </success-criteria>
    </step>

    <definition-of-done>
      <item>Code implemented following project TypeScript patterns</item>
      <item>All acceptance criteria met</item>
      <item>Unit tests written with &gt;95% coverage</item>
      <item>All tests passing in CI pipeline</item>
      <item>TypeScript types properly defined (strict mode)</item>
      <item>Code reviewed and approved</item>
      <item>Environment variable documented in .env.example</item>
      <item>Inline code comments explain security properties</item>
      <item>No ESLint or TypeScript errors</item>
      <item>Exported from packages/shared/src/index.ts for use in other packages</item>
    </definition-of-done>
  </implementation-guide>

  <reference-implementation>
    <source>docs/sprint-artifacts/tech-spec-epic-06.md (lines 111-191)</source>
    <description>
      Complete reference implementation provided in tech spec. Key points:

      - Constructor validates master key presence, base64 encoding, and length
      - Encryption uses crypto.randomBytes() for salt and IV generation
      - Key derivation uses crypto.pbkdf2Sync()
      - Encryption uses crypto.createCipheriv()
      - Authentication tag extracted with cipher.getAuthTag()
      - Components combined with Buffer.concat()
      - Final output base64-encoded

      - Decryption reverses process
      - Buffer.from() to decode base64
      - Buffer.subarray() to extract components
      - crypto.createDecipheriv() for decryption
      - decipher.setAuthTag() for tamper detection
      - Automatic validation throws if tampered
    </description>
  </reference-implementation>

  <performance-considerations>
    <note>
      PBKDF2 with 100,000 iterations is intentionally slow (50-100ms per operation).
      This is a security trade-off to protect against brute force attacks.
      Acceptable for infrequent operations (API key configuration).
      Not suitable for high-frequency operations.
    </note>
  </performance-considerations>

  <out-of-scope>
    <item>Database models for AI provider configuration (already exists in schema)</item>
    <item>API endpoints for provider management (Story 06.3)</item>
    <item>Key rotation mechanism (post-MVP)</item>
    <item>Multi-key version support (post-MVP)</item>
    <item>Integration with external KMS systems</item>
    <item>Frontend UI components</item>
    <item>Python equivalent for AgentOS (Story 06.9 - separate implementation)</item>
  </out-of-scope>

  <questions-and-notes>
    <note>
      Implementation is well-specified in tech spec. No open questions at this time.
    </note>
    <note>
      Service will be used across both NestJS backend and potentially Next.js frontend
      (though API keys should never be sent to frontend - this is backend/agent-only).
    </note>
  </questions-and-notes>

  <related-documentation>
    <document>docs/sprint-artifacts/tech-spec-epic-06.md</document>
    <document>docs/architecture.md (security section)</document>
    <external href="https://csrc.nist.gov/publications/detail/sp/800-38d/final">NIST AES-GCM Specification</external>
    <external href="https://nodejs.org/api/crypto.html">Node.js Crypto Module Documentation</external>
  </related-documentation>
</story-context>
