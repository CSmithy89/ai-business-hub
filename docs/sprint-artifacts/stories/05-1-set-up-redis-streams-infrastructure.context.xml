<?xml version="1.0" encoding="UTF-8"?>
<story-context>
  <story-id>05-1</story-id>
  <story-title>Set Up Redis Streams Infrastructure</story-title>
  <generated>2025-12-03</generated>

  <epic-context>
    <epic-id>EPIC-05</epic-id>
    <epic-title>Event Bus Infrastructure</epic-title>
    <tech-spec-location>docs/sprint-artifacts/tech-spec-epic-05.md</tech-spec-location>
    <tech-spec-section>Story 05.1: Set Up Redis Streams Infrastructure</tech-spec-section>
  </epic-context>

  <story-summary>
    Create the EventsModule in NestJS with Redis Streams infrastructure for the event bus.
    This includes setting up consumer groups, stream creation with MKSTREAM flags, retention
    policies, and health check endpoints. This is the foundation for all subsequent event
    bus stories (05-2 through 05-7).
  </story-summary>

  <dependencies>
    <dependency type="infrastructure">
      <name>Redis 7</name>
      <status>configured</status>
      <location>docker/docker-compose.yml</location>
      <notes>Already running with appendonly persistence. Currently used for BullMQ queues.</notes>
    </dependency>

    <dependency type="package">
      <name>@nestjs/bullmq</name>
      <version>^11.0.4</version>
      <status>installed</status>
      <location>apps/api/package.json</location>
      <notes>Already configured in app.module.ts with Redis connection</notes>
    </dependency>

    <dependency type="package">
      <name>bullmq</name>
      <version>^5.65.1</version>
      <status>installed</status>
      <location>apps/api/package.json</location>
      <notes>Provides Redis client (ioredis) that can be reused for streams</notes>
    </dependency>

    <dependency type="configuration">
      <name>Redis Environment Variables</name>
      <status>configured</status>
      <location>.env.example</location>
      <variables>
        <variable name="REDIS_URL">redis://localhost:6379</variable>
        <variable name="REDIS_HOST">localhost (extracted by ConfigService)</variable>
        <variable name="REDIS_PORT">6379 (extracted by ConfigService)</variable>
        <variable name="REDIS_PASSWORD">optional</variable>
      </variables>
    </dependency>

    <dependency type="code">
      <name>Event Type Definitions</name>
      <status>complete</status>
      <location>packages/shared/src/types/events.ts</location>
      <notes>BaseEvent interface, EventTypes constants, and typed payloads already defined</notes>
    </dependency>

    <dependency type="code">
      <name>EventBusService Stub</name>
      <status>to-be-replaced</status>
      <location>apps/api/src/approvals/stubs/event-bus.stub.ts</location>
      <notes>Current stub logs events. Will be replaced by EventPublisherService in Story 05-2</notes>
    </dependency>
  </dependencies>

  <existing-code>
    <file path="apps/api/src/app.module.ts">
      <summary>NestJS root module - EventsModule will be imported here</summary>
      <relevant-sections>
        <section>
          <lines>14-30</lines>
          <description>BullMQ configuration with Redis connection</description>
          <code><![CDATA[
    BullModule.forRootAsync({
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => ({
        connection: {
          host: configService.get('REDIS_HOST', 'localhost'),
          port: configService.get('REDIS_PORT', 6379),
          password: configService.get('REDIS_PASSWORD'),
        },
      }),
    }),
          ]]></code>
          <notes>
            Existing Redis connection configuration. EventsModule will use similar pattern
            but may need direct Redis client access for XGROUP, XADD, XREADGROUP commands.
          </notes>
        </section>

        <section>
          <lines>31-36</lines>
          <description>Module imports list</description>
          <code><![CDATA[
    CommonModule,
    AuditModule,
    MembersModule,
    ApprovalsModule,
    AgentOSModule,
          ]]></code>
          <notes>
            EventsModule should be added here, early in the import list since
            other modules will depend on EventPublisherService.
          </notes>
        </section>
      </relevant-sections>
    </file>

    <file path="apps/api/src/approvals/approvals.module.ts">
      <summary>Example of existing NestJS module structure with BullMQ</summary>
      <relevant-sections>
        <section>
          <lines>28-34</lines>
          <description>BullMQ queue registration pattern</description>
          <code><![CDATA[
@Module({
  imports: [
    BullModule.registerQueue({
      name: 'approval-escalation',
    }),
  ],
          ]]></code>
          <notes>
            EventsModule will use BullModule.registerQueue for 'event-retry' queue.
            Follow this same pattern.
          </notes>
        </section>

        <section>
          <lines>35-45</lines>
          <description>Service providers and exports</description>
          <code><![CDATA[
  providers: [
    ApprovalsService,
    ConfidenceCalculatorService,
    ApprovalRouterService,
    ApprovalEscalationService,
    ApprovalAuditService,
    EscalationSchedulerService,
    EscalationProcessor,
    EventBusService,
  ],
  exports: [
    ApprovalsService,
    ConfidenceCalculatorService,
    ApprovalRouterService,
    ApprovalEscalationService,
    ApprovalAuditService,
  ],
          ]]></code>
          <notes>
            EventsModule should export EventPublisherService so other modules can inject it.
            Only services, not processors, should be exported.
          </notes>
        </section>
      </relevant-sections>
    </file>

    <file path="docker/docker-compose.yml">
      <summary>Redis 7 container configuration</summary>
      <relevant-sections>
        <section>
          <lines>25-41</lines>
          <description>Redis service definition</description>
          <code><![CDATA[
  redis:
    image: redis:7-alpine
    container_name: hyvve_redis
    restart: unless-stopped
    command: redis-server --appendonly yes
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - hyvve_network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
          ]]></code>
          <notes>
            Redis is already configured with persistence (appendonly yes).
            No changes needed for Story 05-1. Future optimization: Could add
            --maxmemory and --maxmemory-policy for production.
          </notes>
        </section>
      </relevant-sections>
    </file>

    <file path="apps/api/src/app.controller.ts">
      <summary>Example of health check endpoint pattern</summary>
      <relevant-sections>
        <section>
          <lines>11-26</lines>
          <description>Health check endpoint</description>
          <code><![CDATA[
  @Get('health')
  @ApiOperation({ summary: 'Health check endpoint' })
  @ApiResponse({
    status: 200,
    description: 'Service is healthy',
  })
  getHealth(): HealthCheckResponse {
    return this.appService.getHealth();
  }
          ]]></code>
          <notes>
            EventsController should follow similar pattern for /health/events endpoint.
            Use @ApiOperation and @ApiResponse decorators for Swagger documentation.
          </notes>
        </section>
      </relevant-sections>
    </file>

    <file path="apps/api/src/common/common.module.ts">
      <summary>Example of shared module pattern</summary>
      <relevant-sections>
        <section>
          <lines>32-53</lines>
          <description>Module structure with providers and exports</description>
          <code><![CDATA[
@Module({
  imports: [],
  providers: [
    // Services
    PrismaService,
    // Guards
    AuthGuard,
    TenantGuard,
    RolesGuard,
  ],
  exports: [
    // Services
    PrismaService,
    // Guards
    AuthGuard,
    TenantGuard,
    RolesGuard,
  ],
})
export class CommonModule {}
          ]]></code>
          <notes>
            CommonModule provides PrismaService globally. EventsModule will inject
            PrismaService for EventMetadata tracking (though the Prisma model
            will be added in future stories).
          </notes>
        </section>
      </relevant-sections>
    </file>

    <file path="packages/shared/src/types/events.ts">
      <summary>Event type definitions and interfaces</summary>
      <relevant-sections>
        <section>
          <lines>10-29</lines>
          <description>BaseEvent interface</description>
          <code><![CDATA[
export interface BaseEvent {
  id: string;
  type: string;
  source: string;
  timestamp: string;
  correlationId?: string;
  tenantId: string;
  userId: string;
  version: string;
  data: Record<string, unknown>;
}
          ]]></code>
          <notes>
            This is the event structure that will be serialized to Redis Streams.
            EventPublisherService (Story 05-2) will construct and validate this.
          </notes>
        </section>

        <section>
          <lines>65-110</lines>
          <description>EventTypes constant with all event names</description>
          <code><![CDATA[
export const EventTypes = {
  APPROVAL_REQUESTED: 'approval.item.requested',
  APPROVAL_APPROVED: 'approval.item.approved',
  AGENT_RUN_COMPLETED: 'agent.run.completed',
  // ... etc
} as const;
          ]]></code>
          <notes>
            These event type constants will be used for pattern matching in
            EventConsumerService (Story 05-3).
          </notes>
        </section>
      </relevant-sections>
    </file>
  </existing-code>

  <implementation-guidance>
    <step order="1">
      <description>Create EventsModule directory structure</description>
      <files>
        <file>apps/api/src/events/events.module.ts</file>
        <file>apps/api/src/events/redis.provider.ts</file>
      </files>
      <details>
        Create the base module structure following existing patterns from
        ApprovalsModule. Use @nestjs/bullmq for Redis connection sharing.
      </details>
      <code-template><![CDATA[
// apps/api/src/events/events.module.ts
import { Module, OnModuleInit } from '@nestjs/common';
import { BullModule } from '@nestjs/bullmq';

@Module({
  imports: [
    BullModule.registerQueue({
      name: 'event-retry',
    }),
  ],
  providers: [
    // Services will be added in future stories
  ],
  controllers: [],
  exports: [],
})
export class EventsModule implements OnModuleInit {
  async onModuleInit() {
    await this.setupStreams();
  }

  private async setupStreams() {
    // Setup consumer groups and streams
  }
}
      ]]></code-template>
    </step>

    <step order="2">
      <description>Create Redis provider for direct stream access</description>
      <files>
        <file>apps/api/src/events/redis.provider.ts</file>
      </files>
      <details>
        BullMQ uses ioredis under the hood. We need direct access to the Redis
        client for XGROUP, XADD, XREADGROUP, etc. Create a provider that injects
        the Redis client from BullMQ's connection.
      </details>
      <code-template><![CDATA[
// apps/api/src/events/redis.provider.ts
import { Injectable } from '@nestjs/common';
import { InjectQueue } from '@nestjs/bullmq';
import { Queue } from 'bullmq';
import Redis from 'ioredis';

@Injectable()
export class RedisProvider {
  private readonly redis: Redis;

  constructor(@InjectQueue('event-retry') private eventRetryQueue: Queue) {
    // Access the underlying Redis client from BullMQ
    this.redis = this.eventRetryQueue.client as Redis;
  }

  getClient(): Redis {
    return this.redis;
  }
}
      ]]></code-template>
      <notes>
        Alternative approach: Create a separate Redis client using ConfigService.
        However, reusing BullMQ's connection is more efficient.
      </notes>
    </step>

    <step order="3">
      <description>Implement stream setup in onModuleInit</description>
      <files>
        <file>apps/api/src/events/events.module.ts</file>
      </files>
      <details>
        Create consumer groups for hyvve:events and hyvve:dlq streams.
        Use MKSTREAM flag to auto-create streams if they don't exist.
        Handle BUSYGROUP error (group already exists) gracefully.
      </details>
      <code-template><![CDATA[
// In EventsModule
private async setupStreams() {
  const redis = this.redisProvider.getClient();

  try {
    // Create main event stream consumer group
    await redis.xgroup(
      'CREATE',
      'hyvve:events',
      'hyvve-platform',
      '0',
      'MKSTREAM'
    );
    this.logger.log('Created consumer group for hyvve:events');
  } catch (error) {
    if (error.message.includes('BUSYGROUP')) {
      this.logger.log('Consumer group for hyvve:events already exists');
    } else {
      throw error;
    }
  }

  // Repeat for hyvve:dlq
  try {
    await redis.xgroup(
      'CREATE',
      'hyvve:dlq',
      'hyvve-platform',
      '0',
      'MKSTREAM'
    );
    this.logger.log('Created consumer group for hyvve:dlq');
  } catch (error) {
    if (error.message.includes('BUSYGROUP')) {
      this.logger.log('Consumer group for hyvve:dlq already exists');
    } else {
      throw error;
    }
  }
}
      ]]></code-template>
      <testing>
        Test that streams and consumer groups are created on first startup.
        Test that subsequent startups don't fail when groups already exist.
        Verify streams exist using: redis-cli XINFO STREAM hyvve:events
      </testing>
    </step>

    <step order="4">
      <description>Create health check endpoint in EventsController</description>
      <files>
        <file>apps/api/src/events/events.controller.ts</file>
      </files>
      <details>
        Add GET /health/events endpoint that returns stream info.
        Use XINFO GROUPS and XPENDING commands to get consumer group status.
      </details>
      <code-template><![CDATA[
// apps/api/src/events/events.controller.ts
import { Controller, Get } from '@nestjs/common';
import { ApiOperation, ApiResponse, ApiTags } from '@nestjs/swagger';

@ApiTags('events')
@Controller('health')
export class EventsController {
  constructor(private readonly redisProvider: RedisProvider) {}

  @Get('events')
  @ApiOperation({ summary: 'Event bus health check' })
  @ApiResponse({
    status: 200,
    description: 'Event bus is healthy',
  })
  async checkEventsHealth() {
    const redis = this.redisProvider.getClient();

    // Get consumer group info
    const groupInfo = await redis.xinfo('GROUPS', 'hyvve:events');

    // Get pending count
    const pendingInfo = await redis.xpending(
      'hyvve:events',
      'hyvve-platform'
    );

    return {
      healthy: true,
      consumerGroup: groupInfo,
      pendingCount: pendingInfo ? pendingInfo[0] : 0,
      timestamp: new Date().toISOString(),
    };
  }
}
      ]]></code-template>
      <acceptance-criteria>
        AC4: Health check endpoint returns stream info (consumer group status, pending count)
      </acceptance-criteria>
    </step>

    <step order="5">
      <description>Import EventsModule in AppModule</description>
      <files>
        <file>apps/api/src/app.module.ts</file>
      </files>
      <details>
        Add EventsModule to imports array in AppModule, early in the list
        (after CommonModule, before ApprovalsModule).
      </details>
      <code-template><![CDATA[
// In app.module.ts imports array
imports: [
  ConfigModule.forRoot({...}),
  BullModule.forRootAsync({...}),
  CommonModule,
  EventsModule,  // <-- Add here
  AuditModule,
  MembersModule,
  ApprovalsModule,
  AgentOSModule,
],
      ]]></code-template>
    </step>

    <step order="6">
      <description>Add constants file for stream configuration</description>
      <files>
        <file>apps/api/src/events/constants/streams.constants.ts</file>
      </files>
      <details>
        Extract stream names, consumer group names, and configuration constants
        to a separate file for maintainability.
      </details>
      <code-template><![CDATA[
// apps/api/src/events/constants/streams.constants.ts
export const STREAMS = {
  MAIN: 'hyvve:events',
  DLQ: 'hyvve:dlq',
  REPLAY: 'hyvve:events:replay',
} as const;

export const CONSUMER_GROUP = 'hyvve-platform';

export const CONSUMER_CONFIG = {
  NAME: process.env.HOSTNAME || `consumer-${process.pid}`,
  BLOCK_TIMEOUT_MS: 5000,
  BATCH_SIZE: 10,
} as const;

export const RETENTION = {
  MAIN_STREAM_DAYS: 30,
  DLQ_DAYS: 90,
  REPLAY_HOURS: 24,
} as const;
      ]]></code-template>
    </step>

    <step order="7">
      <description>Write unit tests for EventsModule</description>
      <files>
        <file>apps/api/src/events/events.module.spec.ts</file>
      </files>
      <details>
        Test module initialization, stream setup, and error handling.
      </details>
      <test-cases>
        <test-case>Should create consumer groups on first init</test-case>
        <test-case>Should handle BUSYGROUP error gracefully</test-case>
        <test-case>Should throw on unexpected Redis errors</test-case>
        <test-case>Should inject RedisProvider successfully</test-case>
      </test-cases>
    </step>

    <step order="8">
      <description>Write integration tests for health endpoint</description>
      <files>
        <file>apps/api/src/events/events.controller.spec.ts</file>
      </files>
      <details>
        Test health endpoint returns correct stream info.
      </details>
      <test-cases>
        <test-case>GET /health/events should return 200 with stream info</test-case>
        <test-case>Should include consumer group status</test-case>
        <test-case>Should include pending count</test-case>
        <test-case>Should handle Redis connection errors</test-case>
      </test-cases>
    </step>
  </implementation-guidance>

  <patterns-to-follow>
    <pattern name="NestJS Module Pattern">
      <description>Follow existing module structure from ApprovalsModule</description>
      <example-location>apps/api/src/approvals/approvals.module.ts</example-location>
      <key-points>
        <point>Use @Module decorator with imports, providers, controllers, exports</point>
        <point>Implement OnModuleInit for initialization logic</point>
        <point>Register BullMQ queues in imports array</point>
        <point>Export services that other modules need to inject</point>
      </key-points>
    </pattern>

    <pattern name="BullMQ Integration">
      <description>Reuse existing BullMQ configuration from AppModule</description>
      <example-location>apps/api/src/app.module.ts (lines 21-30)</example-location>
      <key-points>
        <point>BullModule.forRootAsync already configured globally</point>
        <point>Use BullModule.registerQueue in feature modules</point>
        <point>Inject Queue with @InjectQueue decorator</point>
        <point>Access underlying Redis client via queue.client</point>
      </key-points>
    </pattern>

    <pattern name="Health Check Endpoints">
      <description>Follow existing health check pattern from AppController</description>
      <example-location>apps/api/src/app.controller.ts</example-location>
      <key-points>
        <point>Use @ApiTags, @ApiOperation, @ApiResponse for Swagger</point>
        <point>Return structured response with timestamp</point>
        <point>Handle errors gracefully and return healthy: false on failure</point>
      </key-points>
    </pattern>

    <pattern name="Configuration via Environment Variables">
      <description>Use ConfigService for configuration values</description>
      <example-location>apps/api/src/config/env.validation.ts</example-location>
      <key-points>
        <point>All config values come from environment variables</point>
        <point>Use ConfigService.get() with defaults</point>
        <point>Validate required variables at startup</point>
        <point>Document all variables in .env.example</point>
      </key-points>
    </pattern>

    <pattern name="Logging">
      <description>Use NestJS Logger for structured logging</description>
      <example-location>apps/api/src/approvals/stubs/event-bus.stub.ts</example-location>
      <key-points>
        <point>Create logger with context: new Logger(ClassName.name)</point>
        <point>Use structured logging with objects: logger.log({ message, ...data })</point>
        <point>Log important events (stream setup, errors)</point>
        <point>Use appropriate log levels (log, warn, error)</point>
      </key-points>
    </pattern>
  </patterns-to-follow>

  <technical-notes>
    <note category="redis-streams">
      <title>Consumer Group Idempotency</title>
      <content>
        The XGROUP CREATE command with MKSTREAM flag will:
        1. Create the stream if it doesn't exist
        2. Create the consumer group
        3. Throw BUSYGROUP error if group already exists

        This is normal and expected. Handle gracefully by catching and logging.
        Starting from ID '0' means the consumer group will process all future events,
        not historical ones (which is correct for our use case).
      </content>
    </note>

    <note category="redis-streams">
      <title>Stream Retention</title>
      <content>
        Redis Streams don't have built-in TTL like keys do. Retention is achieved by:
        1. Using XTRIM during writes (MAXLEN ~ approximate)
        2. Periodic cleanup jobs

        For Story 05-1, we're NOT implementing retention yet. Just creating the streams.
        Retention will be added incrementally in Story 05-2 (publisher does XTRIM on write).
      </content>
    </note>

    <note category="architecture">
      <title>Service Dependencies</title>
      <content>
        Story 05-1 creates the foundation but NO services yet:
        - EventPublisherService → Story 05-2
        - EventConsumerService → Story 05-3
        - EventRetryService → Story 05-4
        - EventReplayService → Story 05-6

        For now, EventsModule only:
        1. Sets up streams and consumer groups on startup
        2. Provides health check endpoint
        3. Exports RedisProvider (optional - services can inject directly)
      </content>
    </note>

    <note category="testing">
      <title>Integration Testing with Redis</title>
      <content>
        Integration tests should use a real Redis instance (from Docker Compose).
        Use @nestjs/testing to create a TestingModule with EventsModule.

        Test setup:
        1. Start Redis container (should already be running for other tests)
        2. Clean up test streams before/after tests (XDEL, DEL)
        3. Use unique stream names for tests to avoid conflicts

        Don't mock Redis for integration tests - we need real stream behavior.
      </content>
    </note>

    <note category="error-handling">
      <title>Graceful Degradation</title>
      <content>
        If Redis is unavailable during module init:
        1. Log error clearly
        2. Allow app to start (don't crash)
        3. Health check endpoint should return unhealthy
        4. Retry connection on next health check

        This allows the API to be partially functional even if event bus is down.
        Critical approval flows can still work (they already log to EventBusService stub).
      </content>
    </note>

    <note category="future-optimization">
      <title>Production Redis Configuration</title>
      <content>
        For production, consider adding to docker-compose.yml:
        - --maxmemory 256mb (or higher based on load)
        - --maxmemory-policy volatile-lru
        - --save "" (disable RDB snapshots, AOF is enough)

        These are NOT required for Story 05-1 (dev environment).
      </content>
    </note>
  </technical-notes>

  <acceptance-criteria>
    <criterion id="AC1">
      <description>Redis connection configured in EventsModule using @nestjs/bullmq</description>
      <verification>
        - EventsModule imports BullModule.registerQueue
        - RedisProvider injects Queue and accesses client
        - Health endpoint successfully connects to Redis
      </verification>
    </criterion>

    <criterion id="AC2">
      <description>Consumer groups created on startup (hyvve:events, hyvve:dlq with consumer group 'hyvve-platform')</description>
      <verification>
        - Run: redis-cli XINFO GROUPS hyvve:events
        - Verify consumer group 'hyvve-platform' exists
        - Repeat for hyvve:dlq
        - Logs show "Created consumer group" or "already exists"
      </verification>
    </criterion>

    <criterion id="AC3">
      <description>Streams auto-created with MKSTREAM flag</description>
      <verification>
        - Run: redis-cli EXISTS hyvve:events
        - Returns 1 (stream exists)
        - Repeat for hyvve:dlq
        - No manual stream creation needed
      </verification>
    </criterion>

    <criterion id="AC4">
      <description>Health check endpoint returns stream info (consumer group status, pending count)</description>
      <verification>
        - GET /health/events returns 200
        - Response includes: healthy, consumerGroup, pendingCount, timestamp
        - Consumer group info shows 'hyvve-platform' group
      </verification>
    </criterion>

    <criterion id="AC5">
      <description>DLQ stream created with 90-day retention</description>
      <verification>
        - Stream hyvve:dlq exists
        - Note: Retention policy will be enforced in Story 05-4 (EventRetryService)
        - For Story 05-1, just verify stream exists
      </verification>
    </criterion>

    <criterion id="AC6">
      <description>Main event stream configured with 30-day retention (via XTRIM)</description>
      <verification>
        - Stream hyvve:events exists
        - Note: XTRIM will be added in Story 05-2 (EventPublisherService)
        - For Story 05-1, just verify stream exists
      </verification>
    </criterion>
  </acceptance-criteria>

  <testing-strategy>
    <unit-tests>
      <test file="apps/api/src/events/events.module.spec.ts">
        <description>Test EventsModule initialization</description>
        <cases>
          <case>Should create consumer groups on first init</case>
          <case>Should handle BUSYGROUP error when groups exist</case>
          <case>Should throw on unexpected Redis errors</case>
          <case>Should log successful stream setup</case>
        </cases>
      </test>

      <test file="apps/api/src/events/redis.provider.spec.ts">
        <description>Test RedisProvider</description>
        <cases>
          <case>Should inject Queue successfully</case>
          <case>Should return Redis client from getClient()</case>
          <case>Should reuse same client instance</case>
        </cases>
      </test>
    </unit-tests>

    <integration-tests>
      <test file="apps/api/test/events-health.e2e-spec.ts">
        <description>Test health endpoint with real Redis</description>
        <cases>
          <case>GET /health/events returns 200 with stream info</case>
          <case>Consumer group info is included in response</case>
          <case>Pending count is 0 for new stream</case>
          <case>Timestamp is valid ISO 8601 string</case>
        </cases>
      </test>

      <test file="apps/api/test/events-streams.e2e-spec.ts">
        <description>Test stream creation and persistence</description>
        <cases>
          <case>Streams exist after module initialization</case>
          <case>Consumer groups exist for both streams</case>
          <case>Restarting app doesn't create duplicate groups</case>
          <case>Can execute XADD on created streams</case>
        </cases>
      </test>
    </integration-tests>

    <manual-verification>
      <step order="1">
        Start Redis: docker-compose up -d redis
      </step>
      <step order="2">
        Start API: cd apps/api && pnpm dev
      </step>
      <step order="3">
        Check logs for: "Created consumer group for hyvve:events"
      </step>
      <step order="4">
        Redis CLI: redis-cli XINFO GROUPS hyvve:events
      </step>
      <step order="5">
        Should see consumer group: name=hyvve-platform, consumers=0, pending=0
      </step>
      <step order="6">
        Test health endpoint: curl http://localhost:3001/health/events
      </step>
      <step order="7">
        Should return JSON with healthy=true and stream info
      </step>
    </manual-verification>
  </testing-strategy>

  <related-stories>
    <story id="05-2" relationship="depends-on">
      <title>Implement Event Publisher</title>
      <description>
        Story 05-2 will create EventPublisherService that uses the streams created here.
        It will inject RedisProvider and use XADD to publish events.
      </description>
    </story>

    <story id="05-3" relationship="depends-on">
      <title>Implement Event Subscriber</title>
      <description>
        Story 05-3 will create EventConsumerService that uses XREADGROUP to consume
        from the consumer groups created here.
      </description>
    </story>

    <story id="05-4" relationship="depends-on">
      <title>Implement Retry and Dead Letter Queue</title>
      <description>
        Story 05-4 will use the hyvve:dlq stream created here to handle failed events.
      </description>
    </story>

    <story id="04-12" relationship="builds-on">
      <title>Implement NestJS AgentOS Bridge</title>
      <description>
        EPIC-04 already has event emission stubs. This story sets up the real
        infrastructure that will replace those stubs.
      </description>
    </story>
  </related-stories>

  <blockers>
    <blocker status="resolved">
      <issue>Redis not available in Docker</issue>
      <resolution>Redis 7 already configured in docker-compose.yml from EPIC-00</resolution>
    </blocker>

    <blocker status="resolved">
      <issue>BullMQ not configured</issue>
      <resolution>BullMQ already configured globally in app.module.ts from Story 04-8</resolution>
    </blocker>

    <blocker status="none">
      <issue>No current blockers for Story 05-1</issue>
      <resolution>All dependencies are in place</resolution>
    </blocker>
  </blockers>

  <implementation-checklist>
    <item>Create apps/api/src/events/ directory</item>
    <item>Create events.module.ts with OnModuleInit</item>
    <item>Create redis.provider.ts to access Redis client</item>
    <item>Create constants/streams.constants.ts for configuration</item>
    <item>Implement stream setup in onModuleInit</item>
    <item>Handle BUSYGROUP error gracefully</item>
    <item>Create events.controller.ts with health endpoint</item>
    <item>Import EventsModule in app.module.ts</item>
    <item>Write unit tests for module initialization</item>
    <item>Write integration tests for health endpoint</item>
    <item>Manual verification with Redis CLI</item>
    <item>Update sprint-status.yaml to ready-for-dev</item>
  </implementation-checklist>
</story-context>
