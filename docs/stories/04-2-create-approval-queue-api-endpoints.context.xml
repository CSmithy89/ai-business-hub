<?xml version="1.0" encoding="UTF-8"?>
<story-context>
  <metadata>
    <story-id>04-2</story-id>
    <story-name>Create Approval Queue API Endpoints</story-name>
    <epic-id>EPIC-04</epic-id>
    <epic-name>Approval Queue System</epic-name>
    <generated-date>2025-12-02</generated-date>
    <status>ready-for-dev</status>
    <priority>P0</priority>
    <points>3</points>
  </metadata>

  <story-definition>
    <user-story>
      As a frontend developer
      I want approval queue API endpoints
      So that I can build the approval UI
    </user-story>

    <description>
      This story implements the complete REST API for the Approval Queue System.
      It provides endpoints for listing, retrieving, approving, rejecting, and bulk
      managing approval items with proper tenant isolation and permission controls.

      The API follows existing NestJS patterns established in Epic 03 (RBAC) and
      integrates with the ConfidenceCalculatorService created in Story 04-1.

      Note: The ApprovalItem model already exists in the Prisma schema from Epic 04
      scaffolding. Event bus and audit logging will use stub implementations as
      the full event bus infrastructure will be implemented in Epic 05.
    </description>

    <acceptance-criteria>
      <criterion id="AC-1" status="pending">
        GET /api/approvals endpoint with filtering (status, type, priority, assignee),
        sorting (dueAt, confidenceScore, createdAt), and pagination (page, limit)
      </criterion>
      <criterion id="AC-2" status="pending">
        GET /api/approvals/:id endpoint returns full approval details including
        related user entities (assignedTo, decidedBy) and AI reasoning
      </criterion>
      <criterion id="AC-3" status="pending">
        POST /api/approvals/:id/approve endpoint updates status to 'approved',
        sets decidedById/decidedAt/decisionNotes, and emits event
      </criterion>
      <criterion id="AC-4" status="pending">
        POST /api/approvals/:id/reject endpoint requires reason field, updates
        status to 'rejected', and logs rejection with reason
      </criterion>
      <criterion id="AC-5" status="pending">
        POST /api/approvals/bulk endpoint processes multiple approvals,
        handles partial failures, returns success/failure per item
      </criterion>
      <criterion id="AC-6" status="pending">
        All endpoints enforce tenant isolation via TenantGuard and workspace filtering
      </criterion>
      <criterion id="AC-7" status="pending">
        Approve/reject/bulk endpoints restricted to owner/admin roles via RolesGuard
      </criterion>
      <criterion id="AC-8" status="pending">
        All approval decisions logged to audit_logs table (stub implementation)
      </criterion>
      <criterion id="AC-9" status="pending">
        All approval actions emit events to event bus (stub implementation)
      </criterion>
    </acceptance-criteria>

    <out-of-scope>
      <item>Event bus implementation (Epic 05)</item>
      <item>Full audit logging implementation (Story 04-9)</item>
      <item>Approval creation endpoint (Story 04-3 - ApprovalRouter)</item>
      <item>Real-time WebSocket updates (Story 04-4)</item>
      <item>Approval escalation (Story 04-8)</item>
    </out-of-scope>
  </story-definition>

  <technical-specification>
    <source-file>docs/sprint-artifacts/tech-spec-epic-04.md</source-file>
    <relevant-sections>
      <section name="Services and Modules">
        ApprovalsService handles CRUD operations and approval lifecycle management.
        ApprovalsController provides REST API endpoints with proper guards.
      </section>
      <section name="Data Models and Contracts">
        ApprovalItem model already exists in Prisma schema (Epic 04 scaffolding).
        DTOs defined for request validation and response formatting.
      </section>
      <section name="APIs and Interfaces">
        Five main endpoints: list, detail, approve, reject, bulk action.
        All endpoints use AuthGuard, TenantGuard, and RolesGuard.
      </section>
    </relevant-sections>

    <key-technical-decisions>
      <decision id="TD-1">
        Use existing ApprovalItem Prisma model - no migration needed
      </decision>
      <decision id="TD-2">
        Stub event bus calls (EventBusService) - full implementation in Epic 05
      </decision>
      <decision id="TD-3">
        Stub audit logging calls (AuditService) - enhanced implementation in Story 04-9
      </decision>
      <decision id="TD-4">
        Only pending items can be approved/rejected - validate status before update
      </decision>
      <decision id="TD-5">
        Bulk actions handle partial failures gracefully - don't fail entire batch
      </decision>
    </key-technical-decisions>
  </technical-specification>

  <architecture-context>
    <system-overview>
      HYVVE uses a hybrid monorepo architecture with Next.js 15 (frontend) and
      NestJS 10 (backend modules). The Approval Queue System is implemented as
      a NestJS module following ADR-002 (Hybrid API pattern).

      Multi-tenant isolation is enforced through ADR-003 (Defense-in-depth):
      - Row-Level Security (RLS) at database level
      - TenantGuard at API level
      - Prisma Client Extensions for automatic filtering
    </system-overview>

    <nestjs-patterns>
      <pattern name="Controller Pattern">
        Controllers use decorator-based routing with:
        - @Controller('resource') for base path
        - @UseGuards(AuthGuard, TenantGuard, RolesGuard) for security
        - @Roles('owner', 'admin') for role-based access
        - @CurrentWorkspace() decorator for tenant context
        - @CurrentUser() decorator for authenticated user
        - @ApiTags() for Swagger documentation
      </pattern>

      <pattern name="Service Pattern">
        Services encapsulate business logic:
        - Constructor injection of dependencies (PrismaService, etc.)
        - Public methods for each business operation
        - Throw NestJS exceptions (NotFoundException, BadRequestException)
        - Return plain objects or Prisma models
        - Logger for structured logging
      </pattern>

      <pattern name="DTO Pattern">
        DTOs use class-validator decorators:
        - @IsString(), @IsOptional(), @IsEnum() for validation
        - @Type() for type transformation
        - @ApiProperty() for Swagger documentation
        - Separate DTOs for requests and responses
      </pattern>

      <pattern name="Module Organization">
        Each module has:
        - {module}.module.ts - Module definition
        - {module}.controller.ts - REST endpoints
        - {module}.service.ts - Business logic
        - dto/ - Request/response DTOs
        - {module}.controller.spec.ts - Integration tests
        - {module}.service.spec.ts - Unit tests
      </pattern>
    </nestjs-patterns>

    <existing-guards>
      <guard name="AuthGuard" location="apps/api/src/common/guards/auth.guard.ts">
        Validates JWT token from Authorization header.
        Extracts user information and attaches to request.
      </guard>
      <guard name="TenantGuard" location="apps/api/src/common/guards/tenant.guard.ts">
        Validates user is member of workspace in route params.
        Extracts workspaceId and attaches to request.
      </guard>
      <guard name="RolesGuard" location="apps/api/src/common/guards/roles.guard.ts">
        Validates user has required role in workspace.
        Used with @Roles() decorator.
      </guard>
    </existing-guards>

    <existing-decorators>
      <decorator name="@CurrentUser()" location="apps/api/src/common/decorators/current-user.decorator.ts">
        Extracts authenticated user from request.
      </decorator>
      <decorator name="@CurrentWorkspace()" location="apps/api/src/common/decorators/current-workspace.decorator.ts">
        Extracts workspace ID from request (set by TenantGuard).
      </decorator>
      <decorator name="@Roles(...roles)" location="apps/api/src/common/decorators/roles.decorator.ts">
        Specifies required roles for endpoint access.
      </decorator>
    </existing-decorators>

    <database-access>
      <pattern name="PrismaService">
        Injected via constructor: private readonly prisma: PrismaService
        Access models: this.prisma.approvalItem.findMany(...)
        Always include workspaceId filter for tenant isolation
      </pattern>

      <pattern name="Tenant Filtering">
        ALWAYS filter by workspaceId in where clauses:
        where: { workspaceId, ...otherFilters }

        This enforces tenant isolation at application level.
        RLS provides defense-in-depth at database level.
      </pattern>

      <pattern name="Relations">
        Use include for related entities:
        include: {
          assignedTo: { select: { id: true, name: true, email: true } },
          decidedBy: { select: { id: true, name: true, email: true } }
        }
      </pattern>
    </database-access>
  </architecture-context>

  <existing-code-patterns>
    <example-controller source="apps/api/src/members/members.controller.ts">
      <![CDATA[
// Controller pattern example from MembersController
@Controller('workspaces/:workspaceId/members')
@UseGuards(AuthGuard, TenantGuard, RolesGuard)
@ApiBearerAuth()
export class MembersController {
  private readonly logger = new Logger(MembersController.name);

  constructor(
    private readonly membersService: MembersService,
    private readonly auditService: AuditService
  ) {}

  @Get()
  @ApiOperation({ summary: 'List all workspace members' })
  @ApiResponse({ status: 200, description: 'Members list retrieved' })
  async listMembers(@CurrentWorkspace() workspaceId: string) {
    return this.membersService.listMembers(workspaceId);
  }

  @Get(':memberId')
  async getMember(
    @CurrentWorkspace() workspaceId: string,
    @Param('memberId') memberId: string
  ) {
    return this.membersService.getMember(workspaceId, memberId);
  }

  @Patch(':memberId/module-permissions')
  @Roles('owner', 'admin')
  async updateModulePermissions(
    @Param('memberId') memberId: string,
    @Body() dto: UpdateModulePermissionsDto,
    @CurrentWorkspace() workspaceId: string,
    @CurrentUser() actor: any,
    @Req() req: Request
  ) {
    // Validate DTO
    // Call service
    // Log to audit
    return result.member;
  }
}
      ]]>
    </example-controller>

    <example-service source="apps/api/src/members/members.service.ts">
      <![CDATA[
// Service pattern example from MembersService
@Injectable()
export class MembersService {
  constructor(private readonly prisma: PrismaService) {}

  async getMember(workspaceId: string, memberId: string) {
    const member = await this.prisma.workspaceMember.findUnique({
      where: {
        id: memberId,
        workspaceId, // ALWAYS filter by workspaceId
      },
      include: {
        user: {
          select: {
            id: true,
            email: true,
            name: true,
            image: true,
          },
        },
      },
    });

    if (!member) {
      throw new NotFoundException('Member not found in this workspace');
    }

    return member;
  }

  async listMembers(workspaceId: string) {
    return this.prisma.workspaceMember.findMany({
      where: { workspaceId },
      include: {
        user: {
          select: { id: true, email: true, name: true, image: true },
        },
      },
      orderBy: { invitedAt: 'desc' },
    });
  }
}
      ]]>
    </example-service>

    <example-audit-logging source="apps/api/src/audit/audit.service.ts">
      <![CDATA[
// Audit logging pattern (stub for this story)
@Injectable()
export class AuditService {
  private readonly logger = new Logger(AuditService.name);

  constructor(private readonly prisma: PrismaService) {}

  async logPermissionOverrideChange(params: PermissionOverrideChangeParams): Promise<void> {
    try {
      await this.prisma.auditLog.create({
        data: {
          workspaceId: params.workspaceId,
          action: 'module_permissions_updated',
          entity: 'workspace_member',
          entityId: params.targetMemberId,
          userId: params.actorId,
          ipAddress: params.ipAddress,
          userAgent: params.userAgent,
          oldValues: { modulePermissions: params.oldPermissions },
          newValues: { modulePermissions: params.newPermissions },
          metadata: {
            changeType: 'module_permissions',
            memberEmail: params.targetMemberEmail,
            description: 'Module permission overrides updated',
          },
        },
      });

      this.logger.log(`Permission override change logged`);
    } catch (error) {
      // Audit logging failure should not block operations
      this.logger.error('Failed to create audit log:', error);
    }
  }
}

// For this story, create stub methods:
async logApprovalDecision(params: { workspaceId, userId, action, approvalId, metadata }): Promise<void> {
  // Stub implementation - log to console
  this.logger.log(`[STUB] Approval decision: ${params.action} by ${params.userId}`);
}
      ]]>
    </example-audit-logging>

    <example-dto source="apps/api/src/members/dto/update-module-permissions.dto.ts">
      <![CDATA[
// DTO pattern example
import { IsObject, IsOptional, IsEnum, IsArray, IsString } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class UpdateModulePermissionsDto {
  @ApiProperty({
    description: 'Module permission overrides map',
    type: 'object',
    required: false,
    example: {
      'bm-crm': { role: 'admin' },
    },
  })
  @IsOptional()
  @IsObject()
  modulePermissions?: Record<string, ModulePermissionOverrideDto> | null;
}
      ]]>
    </example-dto>
  </existing-code-patterns>

  <database-schema>
    <prisma-model name="ApprovalItem" location="packages/db/prisma/schema.prisma">
      <![CDATA[
model ApprovalItem {
  id          String @id @default(uuid())
  workspaceId String @map("workspace_id")

  type        String
  title       String
  description String? @db.Text

  confidenceScore   Int     @map("confidence_score")
  confidenceFactors Json?   @map("confidence_factors")
  aiRecommendation  String  @map("ai_recommendation")
  aiReasoning       String? @map("ai_reasoning") @db.Text

  previewUrl      String? @map("preview_url")
  previewData     Json?   @map("preview_data")
  relatedEntities Json?   @map("related_entities")

  sourceModule String? @map("source_module")
  sourceId     String? @map("source_id")

  status   String @default("pending")
  priority String @default("medium")

  requestedBy   String  @map("requested_by")
  assignedToId  String? @map("assigned_to_id")
  escalatedToId String? @map("escalated_to_id")

  dueAt        DateTime  @map("due_at")
  resolvedAt   DateTime? @map("resolved_at")
  resolvedById String?   @map("resolved_by_id")

  resolution Json?

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  workspace  Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  assignedTo User?     @relation("AssignedApprovals", fields: [assignedToId], references: [id])
  resolvedBy User?     @relation("ResolvedApprovals", fields: [resolvedById], references: [id])

  @@index([workspaceId, status])
  @@index([assignedToId, status])
  @@index([dueAt])
  @@index([status, priority])
  @@map("approval_items")
}
      ]]>
    </prisma-model>

    <notes>
      - ApprovalItem model already exists from Epic 04 scaffolding - no migration needed
      - Status values: 'pending', 'approved', 'rejected', 'auto_approved', 'escalated'
      - Priority values: 'low', 'medium', 'high', 'urgent'
      - confidenceScore stored as integer (0-100)
      - confidenceFactors stored as JSON (ConfidenceFactor[])
      - Indexes on [workspaceId, status] for fast list queries
      - Relations to User model for assignedTo/resolvedBy
      - Note: Model uses resolvedBy/resolvedAt but story uses decidedBy/decidedAt naming
        in API responses - map these fields in the service layer
    </notes>
  </database-schema>

  <file-structure>
    <module-location>apps/api/src/approvals/</module-location>

    <files-to-create>
      <file path="apps/api/src/approvals/approvals.controller.ts">
        REST API controller with 5 endpoints (list, detail, approve, reject, bulk)
      </file>
      <file path="apps/api/src/approvals/approvals.service.ts">
        Business logic service with CRUD operations
      </file>
      <file path="apps/api/src/approvals/dto/approval-query.dto.ts">
        Query parameters DTO for list endpoint
      </file>
      <file path="apps/api/src/approvals/dto/approve-item.dto.ts">
        Request body DTO for approve endpoint
      </file>
      <file path="apps/api/src/approvals/dto/reject-item.dto.ts">
        Request body DTO for reject endpoint (requires reason)
      </file>
      <file path="apps/api/src/approvals/dto/bulk-approval.dto.ts">
        Request body DTO for bulk action endpoint
      </file>
      <file path="apps/api/src/approvals/dto/approval-response.dto.ts">
        Response interfaces (ApprovalResponseDto, PaginatedResponse, BulkActionResult)
      </file>
      <file path="apps/api/src/approvals/stubs/event-bus.stub.ts">
        Stub EventBusService for event emission (placeholder for Epic 05)
      </file>
      <file path="apps/api/src/approvals/stubs/audit-logger.stub.ts">
        Stub AuditLogService for audit logging (placeholder for Story 04-9)
      </file>
      <file path="apps/api/src/approvals/approvals.service.spec.ts">
        Unit tests for ApprovalsService
      </file>
      <file path="apps/api/src/approvals/approvals.controller.spec.ts">
        Integration tests for ApprovalsController
      </file>
    </files-to-create>

    <files-to-modify>
      <file path="apps/api/src/approvals/approvals.module.ts">
        Add ApprovalsController and ApprovalsService to module
      </file>
    </files-to-modify>

    <files-already-exist>
      <file path="apps/api/src/approvals/services/confidence-calculator.service.ts">
        Created in Story 04-1 - import and use for confidence calculations
      </file>
      <file path="packages/db/prisma/schema.prisma">
        ApprovalItem model already exists from Epic 04 scaffolding
      </file>
      <file path="apps/api/src/common/guards/auth.guard.ts">
        JWT authentication guard
      </file>
      <file path="apps/api/src/common/guards/tenant.guard.ts">
        Workspace membership validation guard
      </file>
      <file path="apps/api/src/common/guards/roles.guard.ts">
        Role-based access control guard
      </file>
    </files-already-exist>
  </file-structure>

  <implementation-checklist>
    <phase name="1. Setup and DTOs">
      <task id="1.1" status="pending">
        Create dto/approval-query.dto.ts with validation for filters, sorting, pagination
      </task>
      <task id="1.2" status="pending">
        Create dto/approve-item.dto.ts with optional notes field
      </task>
      <task id="1.3" status="pending">
        Create dto/reject-item.dto.ts with required reason field
      </task>
      <task id="1.4" status="pending">
        Create dto/bulk-approval.dto.ts with validation for bulk actions
      </task>
      <task id="1.5" status="pending">
        Create dto/approval-response.dto.ts with interfaces for responses
      </task>
    </phase>

    <phase name="2. Stub Services">
      <task id="2.1" status="pending">
        Create stubs/event-bus.stub.ts with emit() method (logs to console)
      </task>
      <task id="2.2" status="pending">
        Create stubs/audit-logger.stub.ts with log() method (logs to console)
      </task>
    </phase>

    <phase name="3. ApprovalsService">
      <task id="3.1" status="pending">
        Implement findAll() with filtering, sorting, pagination, tenant isolation
      </task>
      <task id="3.2" status="pending">
        Implement findOne() with tenant check and related user entities
      </task>
      <task id="3.3" status="pending">
        Implement approve() with status update, event emission, audit logging
      </task>
      <task id="3.4" status="pending">
        Implement reject() with required reason, status update, event emission
      </task>
      <task id="3.5" status="pending">
        Implement bulkAction() with partial failure handling and progress tracking
      </task>
      <task id="3.6" status="pending">
        Add proper error handling (NotFoundException, BadRequestException)
      </task>
      <task id="3.7" status="pending">
        Add structured logging for all operations
      </task>
    </phase>

    <phase name="4. ApprovalsController">
      <task id="4.1" status="pending">
        Create controller with @Controller('approvals') decorator
      </task>
      <task id="4.2" status="pending">
        Add guards: @UseGuards(AuthGuard, TenantGuard, RolesGuard)
      </task>
      <task id="4.3" status="pending">
        Implement GET /approvals with @Roles('owner', 'admin', 'member')
      </task>
      <task id="4.4" status="pending">
        Implement GET /approvals/:id with @Roles('owner', 'admin', 'member')
      </task>
      <task id="4.5" status="pending">
        Implement POST /approvals/:id/approve with @Roles('owner', 'admin')
      </task>
      <task id="4.6" status="pending">
        Implement POST /approvals/:id/reject with @Roles('owner', 'admin')
      </task>
      <task id="4.7" status="pending">
        Implement POST /approvals/bulk with @Roles('owner', 'admin')
      </task>
      <task id="4.8" status="pending">
        Add Swagger documentation with @ApiTags, @ApiOperation, @ApiResponse
      </task>
    </phase>

    <phase name="5. Module Integration">
      <task id="5.1" status="pending">
        Update approvals.module.ts to register controller and service
      </task>
      <task id="5.2" status="pending">
        Register stub services (EventBusService, AuditLogService)
      </task>
      <task id="5.3" status="pending">
        Ensure PrismaService is imported from CommonModule
      </task>
    </phase>

    <phase name="6. Testing">
      <task id="6.1" status="pending">
        Write unit tests for ApprovalsService (100% coverage target)
      </task>
      <task id="6.2" status="pending">
        Write integration tests for ApprovalsController
      </task>
      <task id="6.3" status="pending">
        Test tenant isolation (cross-tenant access blocked)
      </task>
      <task id="6.4" status="pending">
        Test permission controls (member cannot approve/reject)
      </task>
      <task id="6.5" status="pending">
        Test validation (reject requires reason, bulk validates action)
      </task>
      <task id="6.6" status="pending">
        Test pagination and filtering
      </task>
      <task id="6.7" status="pending">
        Test partial failure handling in bulk actions
      </task>
    </phase>

    <phase name="7. Documentation and Cleanup">
      <task id="7.1" status="pending">
        Add JSDoc comments to all public methods
      </task>
      <task id="7.2" status="pending">
        Document stub services with TODO comments for Epic 05
      </task>
      <task id="7.3" status="pending">
        Test all endpoints with Postman/Insomnia
      </task>
      <task id="7.4" status="pending">
        Update story file with implementation notes
      </task>
    </phase>
  </implementation-checklist>

  <api-specifications>
    <endpoint method="GET" path="/api/approvals">
      <description>List approvals with filtering, sorting, and pagination</description>
      <auth>Owner, Admin, or Member</auth>
      <query-parameters>
        <param name="status" type="enum" optional="true">
          Filter by status: 'pending', 'approved', 'rejected', 'auto_approved', 'escalated'
        </param>
        <param name="type" type="string" optional="true">
          Filter by type: 'content', 'email', 'campaign', 'deal', 'integration', 'agent_action'
        </param>
        <param name="priority" type="enum" optional="true">
          Filter by priority: 'low', 'medium', 'high', 'urgent'
        </param>
        <param name="assigneeId" type="string" optional="true">
          Filter by assigned user ID
        </param>
        <param name="sortBy" type="enum" optional="true" default="createdAt">
          Sort field: 'dueAt', 'confidenceScore', 'createdAt'
        </param>
        <param name="sortOrder" type="enum" optional="true" default="desc">
          Sort direction: 'asc', 'desc'
        </param>
        <param name="page" type="number" optional="true" default="1" min="1">
          Page number
        </param>
        <param name="limit" type="number" optional="true" default="20" min="1" max="100">
          Items per page
        </param>
      </query-parameters>
      <response-example>
        <![CDATA[
{
  "items": [
    {
      "id": "uuid",
      "type": "content",
      "title": "Blog post: AI in Business",
      "confidenceScore": 72.5,
      "status": "pending",
      "priority": "medium",
      "dueAt": "2025-12-04T12:00:00Z",
      "createdAt": "2025-12-02T10:30:00Z"
    }
  ],
  "total": 45,
  "page": 1,
  "limit": 20,
  "totalPages": 3
}
        ]]>
      </response-example>
      <http-codes>
        <code status="200">Success</code>
        <code status="400">Invalid query parameters</code>
        <code status="401">Not authenticated</code>
        <code status="403">Not authorized</code>
      </http-codes>
    </endpoint>

    <endpoint method="GET" path="/api/approvals/:id">
      <description>Get full approval details including AI reasoning</description>
      <auth>Owner, Admin, or Member</auth>
      <path-parameters>
        <param name="id" type="string">Approval item UUID</param>
      </path-parameters>
      <response-example>
        <![CDATA[
{
  "id": "uuid",
  "workspaceId": "workspace-uuid",
  "type": "content",
  "title": "Blog post: AI in Business",
  "description": "Approval for publishing blog post",
  "previewData": { "contentType": "blog_post", "wordCount": 1500 },
  "confidenceScore": 72.5,
  "factors": [
    {
      "factor": "historical_accuracy",
      "score": 85,
      "weight": 0.25,
      "explanation": "85% of similar posts were approved",
      "concerning": false
    }
  ],
  "aiReasoning": null,
  "status": "pending",
  "recommendation": "review",
  "reviewType": "quick",
  "priority": "medium",
  "assignedToId": "user-uuid",
  "assignedTo": {
    "id": "user-uuid",
    "name": "John Doe",
    "email": "john@example.com"
  },
  "dueAt": "2025-12-04T12:00:00Z",
  "createdAt": "2025-12-02T10:30:00Z"
}
        ]]>
      </response-example>
      <http-codes>
        <code status="200">Success</code>
        <code status="401">Not authenticated</code>
        <code status="403">Not authorized or wrong workspace</code>
        <code status="404">Approval not found</code>
      </http-codes>
    </endpoint>

    <endpoint method="POST" path="/api/approvals/:id/approve">
      <description>Approve an approval item with optional notes</description>
      <auth>Owner or Admin only</auth>
      <path-parameters>
        <param name="id" type="string">Approval item UUID</param>
      </path-parameters>
      <request-body>
        <![CDATA[
{
  "notes": "Looks good to publish"
}
        ]]>
      </request-body>
      <response-example>
        <![CDATA[
{
  "id": "uuid",
  "status": "approved",
  "decidedById": "user-uuid",
  "decidedAt": "2025-12-02T11:00:00Z",
  "decisionNotes": "Looks good to publish"
}
        ]]>
      </response-example>
      <http-codes>
        <code status="200">Success</code>
        <code status="400">Invalid request (already decided, invalid status)</code>
        <code status="401">Not authenticated</code>
        <code status="403">Not authorized (requires admin/owner)</code>
        <code status="404">Approval not found</code>
      </http-codes>
    </endpoint>

    <endpoint method="POST" path="/api/approvals/:id/reject">
      <description>Reject an approval item with required reason</description>
      <auth>Owner or Admin only</auth>
      <path-parameters>
        <param name="id" type="string">Approval item UUID</param>
      </path-parameters>
      <request-body>
        <![CDATA[
{
  "reason": "Content needs more citations",
  "notes": "Please add 3 more academic sources"
}
        ]]>
      </request-body>
      <response-example>
        <![CDATA[
{
  "id": "uuid",
  "status": "rejected",
  "decidedById": "user-uuid",
  "decidedAt": "2025-12-02T11:00:00Z",
  "decisionNotes": "Content needs more citations\n\nPlease add 3 more academic sources"
}
        ]]>
      </response-example>
      <http-codes>
        <code status="200">Success</code>
        <code status="400">Invalid request (missing reason, already decided)</code>
        <code status="401">Not authenticated</code>
        <code status="403">Not authorized (requires admin/owner)</code>
        <code status="404">Approval not found</code>
      </http-codes>
    </endpoint>

    <endpoint method="POST" path="/api/approvals/bulk">
      <description>Bulk approve or reject multiple approval items</description>
      <auth>Owner or Admin only</auth>
      <request-body>
        <![CDATA[
{
  "ids": ["uuid1", "uuid2", "uuid3"],
  "action": "approve",
  "notes": "Batch approved - all look good"
}
        ]]>
      </request-body>
      <response-example>
        <![CDATA[
{
  "successes": ["uuid1", "uuid2"],
  "failures": [
    {
      "id": "uuid3",
      "error": "Already approved"
    }
  ],
  "totalProcessed": 3
}
        ]]>
      </response-example>
      <http-codes>
        <code status="200">Success (even with partial failures)</code>
        <code status="400">Invalid request (empty ids, missing reason for reject)</code>
        <code status="401">Not authenticated</code>
        <code status="403">Not authorized (requires admin/owner)</code>
      </http-codes>
    </endpoint>
  </api-specifications>

  <testing-requirements>
    <unit-tests>
      <test-case id="UT-1">
        findAll() returns paginated results with filters and sorting
      </test-case>
      <test-case id="UT-2">
        findAll() respects tenant isolation (only returns workspace approvals)
      </test-case>
      <test-case id="UT-3">
        findOne() returns full approval with related user entities
      </test-case>
      <test-case id="UT-4">
        findOne() throws NotFoundException for invalid ID or wrong workspace
      </test-case>
      <test-case id="UT-5">
        approve() updates status to 'approved' and sets decided fields
      </test-case>
      <test-case id="UT-6">
        approve() throws BadRequestException if already decided
      </test-case>
      <test-case id="UT-7">
        approve() emits 'approval.approved' event (stub verification)
      </test-case>
      <test-case id="UT-8">
        approve() logs to audit trail (stub verification)
      </test-case>
      <test-case id="UT-9">
        reject() updates status to 'rejected' with reason in notes
      </test-case>
      <test-case id="UT-10">
        reject() throws BadRequestException if already decided
      </test-case>
      <test-case id="UT-11">
        reject() throws BadRequestException if reason is missing
      </test-case>
      <test-case id="UT-12">
        bulkAction() processes multiple approvals successfully
      </test-case>
      <test-case id="UT-13">
        bulkAction() handles partial failures gracefully (returns successes and failures)
      </test-case>
      <test-case id="UT-14">
        bulkAction() validates reject action has reason field
      </test-case>
      <test-case id="UT-15">
        bulkAction() emits events for each successful action
      </test-case>
    </unit-tests>

    <integration-tests>
      <test-case id="IT-1">
        GET /api/approvals returns 200 with valid JWT token
      </test-case>
      <test-case id="IT-2">
        GET /api/approvals returns 401 without valid token
      </test-case>
      <test-case id="IT-3">
        GET /api/approvals respects query parameters (status, type, pagination)
      </test-case>
      <test-case id="IT-4">
        GET /api/approvals/:id returns 200 for valid ID
      </test-case>
      <test-case id="IT-5">
        GET /api/approvals/:id returns 404 for invalid ID
      </test-case>
      <test-case id="IT-6">
        GET /api/approvals/:id returns 403 for wrong workspace
      </test-case>
      <test-case id="IT-7">
        POST /api/approvals/:id/approve returns 200 for admin role
      </test-case>
      <test-case id="IT-8">
        POST /api/approvals/:id/approve returns 403 for member role
      </test-case>
      <test-case id="IT-9">
        POST /api/approvals/:id/reject returns 200 with reason
      </test-case>
      <test-case id="IT-10">
        POST /api/approvals/:id/reject returns 400 without reason
      </test-case>
      <test-case id="IT-11">
        POST /api/approvals/bulk returns 200 with success/failure summary
      </test-case>
      <test-case id="IT-12">
        POST /api/approvals/bulk handles validation errors
      </test-case>
    </integration-tests>

    <security-tests>
      <test-case id="ST-1">
        Cross-tenant access is blocked (user cannot access other workspace approvals)
      </test-case>
      <test-case id="ST-2">
        Member role cannot approve/reject (only admin/owner)
      </test-case>
      <test-case id="ST-3">
        Status validation prevents approval of non-pending items
      </test-case>
    </security-tests>
  </testing-requirements>

  <dependencies>
    <dependency type="story" id="04-1">
      ConfidenceCalculatorService (completed)
    </dependency>
    <dependency type="epic" id="00">
      Project scaffolding - NestJS setup, Prisma, TypeScript
    </dependency>
    <dependency type="epic" id="01">
      Authentication - JWT guards, better-auth
    </dependency>
    <dependency type="epic" id="02">
      Workspace Management - workspace model, tenant context
    </dependency>
    <dependency type="epic" id="03">
      RBAC & Multi-tenancy - tenant guards, role guards, audit logs
    </dependency>
  </dependencies>

  <blocking-for>
    <story id="04-3">
      Implement Approval Router (needs endpoints to route to)
    </story>
    <story id="04-4">
      Create Approval Queue Dashboard (needs API to fetch data)
    </story>
  </blocking-for>

  <notes>
    <note type="important">
      ApprovalItem model already exists in Prisma schema - do not create migration.
      The model uses resolvedBy/resolvedAt fields but story documentation uses
      decidedBy/decidedAt naming. Map these fields in service responses.
    </note>
    <note type="important">
      Event bus and audit logging use stub implementations. Add TODO comments
      noting that full implementations will come in Epic 05 and Story 04-9.
    </note>
    <note type="security">
      ALWAYS filter by workspaceId in all database queries for tenant isolation.
      This is critical for data security.
    </note>
    <note type="implementation">
      Bulk actions should handle partial failures gracefully. Track successes
      and failures separately, emit events for successes, return summary.
    </note>
    <note type="validation">
      Only pending items can be approved/rejected. Validate status before
      attempting update. Throw BadRequestException with clear message.
    </note>
    <note type="testing">
      Integration tests should use real database (test database) and verify
      tenant isolation, permission controls, and validation logic.
    </note>
  </notes>

  <definition-of-done>
    <criterion id="DOD-1" status="pending">
      ApprovalsController implemented with all 5 endpoints
    </criterion>
    <criterion id="DOD-2" status="pending">
      ApprovalsService implemented with all business logic methods
    </criterion>
    <criterion id="DOD-3" status="pending">
      All DTOs created with class-validator decorators
    </criterion>
    <criterion id="DOD-4" status="pending">
      Tenant isolation enforced on all queries (workspaceId filter)
    </criterion>
    <criterion id="DOD-5" status="pending">
      Permission guards applied correctly (admin/owner for approve/reject)
    </criterion>
    <criterion id="DOD-6" status="pending">
      Filtering and sorting working correctly on list endpoint
    </criterion>
    <criterion id="DOD-7" status="pending">
      Pagination working with correct total count and page calculation
    </criterion>
    <criterion id="DOD-8" status="pending">
      Approve endpoint updates status and logs decision (stub)
    </criterion>
    <criterion id="DOD-9" status="pending">
      Reject endpoint requires reason and logs decision (stub)
    </criterion>
    <criterion id="DOD-10" status="pending">
      Bulk action endpoint processes multiple items with partial failure handling
    </criterion>
    <criterion id="DOD-11" status="pending">
      Event emission stubbed (console logging with TODO comments)
    </criterion>
    <criterion id="DOD-12" status="pending">
      Audit logging stubbed (console logging with TODO comments)
    </criterion>
    <criterion id="DOD-13" status="pending">
      Unit tests written and passing (100% coverage target)
    </criterion>
    <criterion id="DOD-14" status="pending">
      Integration tests written and passing
    </criterion>
    <criterion id="DOD-15" status="pending">
      Security tests passing (tenant isolation, permission checks)
    </criterion>
    <criterion id="DOD-16" status="pending">
      API endpoints tested manually with Postman/Insomnia
    </criterion>
    <criterion id="DOD-17" status="pending">
      Code reviewed and approved by team
    </criterion>
    <criterion id="DOD-18" status="pending">
      JSDoc comments added to all public methods
    </criterion>
    <criterion id="DOD-19" status="pending">
      Story file updated with implementation notes
    </criterion>
  </definition-of-done>
</story-context>
