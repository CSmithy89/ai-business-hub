<?xml version="1.0" encoding="UTF-8"?>
<story-context>
  <metadata>
    <story-id>pm-05-3-scope-checkpoint-reminders</story-id>
    <epic>PM-05</epic>
    <title>Scope Checkpoint Reminders</title>
    <status>ready-for-dev</status>
    <points>3</points>
    <generated-date>2025-12-19</generated-date>
  </metadata>

  <!-- ========================================
       STORY SUMMARY
       ======================================== -->
  <summary>
    <user-story>
      As a **project lead**,
      I want **reminders for phase checkpoints**,
      So that **I don't miss important milestones**.
    </user-story>

    <acceptance-criteria>
      <criterion id="AC1">
        <description>Create Phase Checkpoint</description>
        <given>I am on a phase detail page</given>
        <when>I create a new checkpoint</when>
        <then>I can specify checkpoint name, date, and description</then>
        <and>The checkpoint is saved with reminder preferences (3 days, 1 day, day-of)</and>
        <and>The checkpoint appears in the phase checkpoints list</and>
      </criterion>

      <criterion id="AC2">
        <description>View Phase Checkpoints</description>
        <given>A phase has checkpoints defined</given>
        <when>I view the phase detail page</when>
        <then>Checkpoints are displayed in chronological order</then>
        <and>Each checkpoint shows name, date, status, and countdown (e.g., "in 3 days")</and>
        <and>Completed checkpoints are marked with a checkmark</and>
      </criterion>

      <criterion id="AC3">
        <description>Checkpoint Reminder Sent at 3 Days Before</description>
        <given>A checkpoint is scheduled 3 days from now</given>
        <when>The daily reminder cron job runs at 8 AM</when>
        <then>A notification is sent with: checkpoint name, phase name, date, outstanding items</then>
        <and>Notification includes a one-click link to open phase review</and>
        <and>The 3-day reminder flag is marked as sent</and>
      </criterion>

      <criterion id="AC4">
        <description>Checkpoint Reminder Sent at 1 Day Before</description>
        <given>A checkpoint is scheduled tomorrow</given>
        <when>The daily reminder cron job runs at 8 AM</when>
        <then>A notification is sent with: checkpoint name, phase name, date, outstanding items</then>
        <and>Notification includes a one-click link to open phase review</and>
        <and>The 1-day reminder flag is marked as sent</and>
      </criterion>

      <criterion id="AC5">
        <description>Checkpoint Reminder Sent on Day-Of</description>
        <given>A checkpoint is scheduled today</given>
        <when>The daily reminder cron job runs at 8 AM</when>
        <then>A notification is sent with: checkpoint name, phase name, date, outstanding items</then>
        <and>Notification includes a one-click link to open phase review</and>
        <and>The day-of reminder flag is marked as sent</and>
      </criterion>

      <criterion id="AC6">
        <description>Suggested Actions in Reminder</description>
        <given>A checkpoint reminder is being generated</given>
        <when>The notification is created</when>
        <then>Outstanding items include: incomplete tasks, blockers, overdue items</then>
        <and>Suggested actions are generated by Scope agent (if enabled)</and>
        <and>Notification provides clear next steps</and>
      </criterion>

      <criterion id="AC7">
        <description>Mark Checkpoint as Completed</description>
        <given>I have completed a checkpoint milestone</given>
        <when>I mark the checkpoint as completed in the UI</when>
        <then>The checkpoint status changes to COMPLETED</then>
        <and>Future reminders for this checkpoint are not sent</and>
        <and>The checkpoint is visually distinguished (checkmark, muted color)</and>
      </criterion>
    </acceptance-criteria>

    <goals>
      - Add reminder sent tracking fields to PhaseCheckpoint model
      - Build PhaseCheckpointList component with create/view/complete functionality
      - Build CheckpointForm component for creating checkpoints
      - Implement CheckpointService with reminder logic
      - Create daily cron job to send reminders at 8 AM
      - Integrate with NotificationService for delivery
      - Add CRUD endpoints for checkpoint management
    </goals>
  </summary>

  <!-- ========================================
       ARCHITECTURE PATTERNS
       ======================================== -->
  <architecture-patterns>
    <cron-job-pattern>
      <name>NestJS Schedule + Cron</name>
      <reference-implementations>
        - apps/api/src/kb/verification/verification-expiry.job.ts (daily midnight)
        - apps/api/src/ai-providers/token-reset.service.ts (daily midnight + weekly)
      </reference-implementations>

      <pattern-structure>
        <![CDATA[
import { Injectable, Logger } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';

@Injectable()
export class CheckpointReminderCron {
  private readonly logger = new Logger(CheckpointReminderCron.name);

  constructor(
    private readonly checkpointService: CheckpointService,
  ) {}

  @Cron(CronExpression.EVERY_DAY_AT_8AM)
  async sendCheckpointReminders(): Promise<void> {
    this.logger.log('Starting checkpoint reminder job...');

    try {
      await this.checkpointService.sendReminders();
      this.logger.log('Checkpoint reminders sent successfully');
    } catch (error) {
      this.logger.error('Failed to send checkpoint reminders', error);
      throw error;
    }
  }
}
        ]]>
      </pattern-structure>

      <key-conventions>
        - Use @Cron decorator with CronExpression.EVERY_DAY_AT_8AM
        - Inject service that contains business logic
        - Use Logger for visibility (start, success, errors)
        - Wrap in try/catch to prevent cron from crashing
        - Process in batches to handle large datasets
        - Include error handling per item (continue processing on single failure)
      </key-conventions>

      <system-user-id>
        For automated actions, use 'SYSTEM' as userId in event publishing
        (See verification-expiry.job.ts line 12)
      </system-user-id>
    </cron-job-pattern>

    <reminder-service-pattern>
      <name>Batch Reminder Processing</name>
      <location>apps/api/src/pm/agents/checkpoint.service.ts</location>

      <pattern-structure>
        <![CDATA[
async sendReminders(): Promise<void> {
  const now = new Date();
  const threeDaysFromNow = new Date(now.getTime() + 3 * 24 * 60 * 60 * 1000);
  const oneDayFromNow = new Date(now.getTime() + 1 * 24 * 60 * 60 * 1000);

  // 3-day reminders
  await this.sendReminderBatch(now, threeDaysFromNow, '3_days');

  // 1-day reminders
  await this.sendReminderBatch(now, oneDayFromNow, '1_day');

  // Day-of reminders
  await this.sendReminderBatch(now, now, 'day_of');
}

private async sendReminderBatch(
  now: Date,
  targetDate: Date,
  interval: '3_days' | '1_day' | 'day_of',
): Promise<void> {
  const startOfDay = new Date(targetDate);
  startOfDay.setHours(0, 0, 0, 0);

  const endOfDay = new Date(targetDate);
  endOfDay.setHours(23, 59, 59, 999);

  // Build where clause based on interval
  const whereClause: any = {
    checkpointDate: {
      gte: startOfDay,
      lte: endOfDay,
    },
    status: 'PENDING',
  };

  // Filter by reminder preference and sent status
  if (interval === '3_days') {
    whereClause.remindAt3Days = true;
    whereClause.reminder3DaysSent = false;
  } else if (interval === '1_day') {
    whereClause.remindAt1Day = true;
    whereClause.reminder1DaySent = false;
  } else {
    whereClause.remindAtDayOf = true;
    whereClause.reminderDayOfSent = false;
  }

  const checkpoints = await this.prisma.phaseCheckpoint.findMany({
    where: whereClause,
    include: {
      phase: {
        include: {
          project: true,
        },
      },
    },
  });

  for (const checkpoint of checkpoints) {
    try {
      await this.sendCheckpointReminder(checkpoint, interval);
    } catch (error) {
      // Log error but continue processing other checkpoints
      this.logger.error(
        `Failed to send reminder for checkpoint ${checkpoint.id}`,
        error,
      );
    }
  }
}
        ]]>
      </pattern-structure>

      <key-conventions>
        - Use start/end of day ranges to handle timezone issues
        - Check both reminder preference (remindAt3Days) and sent status (reminder3DaysSent)
        - Process checkpoints in loop with individual error handling
        - Update sent flag immediately after sending
        - Skip COMPLETED or CANCELLED checkpoints
      </key-conventions>
    </reminder-service-pattern>

    <notification-integration-pattern>
      <name>NotificationService Integration</name>
      <reference>apps/api/src/notifications/notification.service.ts</reference>

      <pattern-structure>
        <![CDATA[
await this.notifications.send({
  workspaceId: project.workspaceId,
  userId: project.ownerId,
  type: 'checkpoint_reminder',
  title: `Checkpoint: ${checkpoint.name}`,
  message: `Checkpoint reminder: "${checkpoint.name}" is ${intervalText} (${this.formatDate(checkpoint.checkpointDate)})`,
  data: {
    checkpointId: checkpoint.id,
    phaseId: phase.id,
    projectId: project.id,
    phaseName: phase.name,
    outstandingItems: outstandingItems.summary,
    suggestedActions,
  },
  actions: [
    {
      label: 'Open Phase',
      url: `/pm/phases/${phase.id}`,
    },
  ],
});
        ]]>
      </pattern-structure>

      <key-conventions>
        - Use descriptive notification type ('checkpoint_reminder')
        - Include actionable data in the data field
        - Provide one-click action with deep link URL
        - Send to project owner (future: all team members)
      </key-conventions>
    </notification-integration-pattern>

    <frontend-component-pattern>
      <name>Checkpoint List with Modal Form</name>
      <reference>apps/web/src/components/pm/phases/PhaseTransitionModal.tsx (modal pattern)</reference>

      <pattern-structure>
        <![CDATA[
export function PhaseCheckpointList({ phaseId }: PhaseCheckpointListProps) {
  const [showForm, setShowForm] = useState(false);
  const queryClient = useQueryClient();

  const { data: checkpoints, isLoading } = useQuery({
    queryKey: ['checkpoints', phaseId],
    queryFn: () =>
      fetch(`/api/pm/phases/${phaseId}/checkpoints`).then(r => r.json()),
  });

  const markCompletedMutation = useMutation({
    mutationFn: (checkpointId: string) =>
      fetch(`/api/pm/phases/${phaseId}/checkpoints/${checkpointId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ status: 'COMPLETED' }),
      }).then(r => r.json()),
    onSuccess: () => {
      queryClient.invalidateQueries(['checkpoints', phaseId]);
      toast.success('Checkpoint marked as completed');
    },
  });

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between">
        <CardTitle>Phase Checkpoints</CardTitle>
        <Button onClick={() => setShowForm(true)}>
          <Plus className="w-4 h-4 mr-2" />
          Add Checkpoint
        </Button>
      </CardHeader>
      <CardContent>
        {checkpoints?.map(checkpoint => (
          <CheckpointItem
            key={checkpoint.id}
            checkpoint={checkpoint}
            onComplete={() => markCompletedMutation.mutate(checkpoint.id)}
          />
        ))}
      </CardContent>

      {showForm && (
        <CheckpointForm
          phaseId={phaseId}
          onClose={() => setShowForm(false)}
          onSuccess={() => {
            setShowForm(false);
            queryClient.invalidateQueries(['checkpoints', phaseId]);
          }}
        />
      )}
    </Card>
  );
}
        ]]>
      </pattern-structure>

      <key-conventions>
        - Use TanStack Query for data fetching
        - Show "Add Checkpoint" button in header
        - Display checkpoints in chronological order
        - Use optimistic updates for better UX
        - Show countdown using date-fns formatDistanceToNow
        - Visual distinction for completed checkpoints (muted colors, checkmark)
      </key-conventions>
    </frontend-component-pattern>
  </architecture-patterns>

  <!-- ========================================
       DATABASE CONTEXT
       ======================================== -->
  <database-schema>
    <existing-model>
      <name>PhaseCheckpoint</name>
      <location>packages/db/prisma/schema.prisma (lines 1403-1429)</location>
      <current-schema>
        <![CDATA[
model PhaseCheckpoint {
  id             String   @id @default(cuid())
  phaseId        String   @map("phase_id")
  name           String
  description    String?  @db.Text
  checkpointDate DateTime @map("checkpoint_date")

  // Status
  status      CheckpointStatus @default(PENDING)
  completedAt DateTime?        @map("completed_at")

  // Reminders (used by PM-05.3)
  remindAt3Days Boolean @default(true) @map("remind_at_3_days")
  remindAt1Day  Boolean @default(true) @map("remind_at_1_day")
  remindAtDayOf Boolean @default(true) @map("remind_at_day_of")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  phase Phase @relation(fields: [phaseId], references: [id], onDelete: Cascade)

  @@index([phaseId])
  @@index([checkpointDate])
  @@map("phase_checkpoints")
}
        ]]>
      </current-schema>

      <note>
        Model exists from PM-05.1 but MISSING sent tracking fields.
        Need to add: reminder3DaysSent, reminder1DaySent, reminderDayOfSent
      </note>
    </existing-model>

    <schema-extensions-needed>
      <extension model="PhaseCheckpoint">
        <![CDATA[
// Add after line 1417 (after remindAtDayOf):

// Sent tracking (to avoid duplicate reminders)
reminder3DaysSent Boolean @default(false) @map("reminder_3_days_sent")
reminder1DaySent  Boolean @default(false) @map("reminder_1_day_sent")
reminderDayOfSent Boolean @default(false) @map("reminder_day_of_sent")
        ]]>
      </extension>

      <migration-command>
        npx prisma migrate dev --name add_checkpoint_reminder_sent_flags
      </migration-command>
    </schema-extensions-needed>

    <checkpoint-status-enum>
      <![CDATA[
enum CheckpointStatus {
  PENDING
  COMPLETED
  CANCELLED
}
      ]]>
    </checkpoint-status-enum>

    <outstanding-items-calculation>
      <query-logic>
        <![CDATA[
// Incomplete tasks
const incompleteTasks = await this.prisma.task.count({
  where: {
    phaseId,
    status: { notIn: ['DONE', 'CANCELLED'] },
  },
});

// Blocked tasks
const blockedTasks = await this.prisma.task.count({
  where: {
    phaseId,
    status: 'BLOCKED',
  },
});

// Overdue tasks
const overdueTasks = await this.prisma.task.count({
  where: {
    phaseId,
    dueDate: { lt: new Date() },
    status: { notIn: ['DONE', 'CANCELLED'] },
  },
});

return {
  summary: `${incompleteTasks} incomplete tasks, ${blockedTasks} blocked, ${overdueTasks} overdue`,
  incompleteTasks,
  blockedTasks,
  overdueTasks,
};
        ]]>
      </query-logic>
    </outstanding-items-calculation>
  </database-schema>

  <!-- ========================================
       API ENDPOINTS CONTEXT
       ======================================== -->
  <api-endpoints>
    <new-endpoints-required>
      <endpoint>
        <method>GET</method>
        <path>/api/pm/phases/:id/checkpoints</path>
        <controller>apps/api/src/pm/phases/phases.controller.ts</controller>
        <service>apps/api/src/pm/agents/checkpoint.service.ts</service>
        <description>List checkpoints for a phase</description>
        <rbac>Roles: owner, admin, member</rbac>

        <controller-implementation>
          <![CDATA[
@Get(':id/checkpoints')
@Roles('owner', 'admin', 'member')
@ApiOperation({ summary: 'List checkpoints for a phase' })
async listCheckpoints(
  @CurrentWorkspace() workspaceId: string,
  @Param('id') phaseId: string,
): Promise<PhaseCheckpoint[]> {
  return this.checkpointService.listCheckpoints(workspaceId, phaseId);
}
          ]]>
        </controller-implementation>

        <response-interface>
          <![CDATA[
interface PhaseCheckpoint {
  id: string;
  phaseId: string;
  name: string;
  description: string | null;
  checkpointDate: string;
  status: 'PENDING' | 'COMPLETED' | 'CANCELLED';
  completedAt: string | null;
  remindAt3Days: boolean;
  remindAt1Day: boolean;
  remindAtDayOf: boolean;
  reminder3DaysSent: boolean;
  reminder1DaySent: boolean;
  reminderDayOfSent: boolean;
  createdAt: string;
  updatedAt: string;
}
          ]]>
        </response-interface>
      </endpoint>

      <endpoint>
        <method>POST</method>
        <path>/api/pm/phases/:id/checkpoints</path>
        <controller>apps/api/src/pm/phases/phases.controller.ts</controller>
        <service>apps/api/src/pm/agents/checkpoint.service.ts</service>
        <description>Create a checkpoint for a phase</description>
        <rbac>Roles: owner, admin, member</rbac>

        <request-dto>
          <![CDATA[
// apps/api/src/pm/agents/dto/checkpoint.dto.ts (NEW FILE)

import { IsString, IsDateString, IsOptional, IsBoolean, MinLength } from 'class-validator';

export class CreateCheckpointDto {
  @IsString()
  @MinLength(1)
  name: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsDateString()
  checkpointDate: string;

  @IsBoolean()
  @IsOptional()
  remindAt3Days?: boolean;

  @IsBoolean()
  @IsOptional()
  remindAt1Day?: boolean;

  @IsBoolean()
  @IsOptional()
  remindAtDayOf?: boolean;
}

export class UpdateCheckpointDto {
  @IsString()
  @IsOptional()
  name?: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsDateString()
  @IsOptional()
  checkpointDate?: string;

  @IsEnum(CheckpointStatus)
  @IsOptional()
  status?: CheckpointStatus;
}
          ]]>
        </request-dto>

        <controller-implementation>
          <![CDATA[
@Post(':id/checkpoints')
@Roles('owner', 'admin', 'member')
@ApiOperation({ summary: 'Create a checkpoint for a phase' })
async createCheckpoint(
  @CurrentWorkspace() workspaceId: string,
  @CurrentUser() user: User,
  @Param('id') phaseId: string,
  @Body() dto: CreateCheckpointDto,
): Promise<PhaseCheckpoint> {
  return this.checkpointService.createCheckpoint(
    workspaceId,
    phaseId,
    user.id,
    dto
  );
}
          ]]>
        </controller-implementation>
      </endpoint>

      <endpoint>
        <method>PUT</method>
        <path>/api/pm/phases/:id/checkpoints/:checkpointId</path>
        <controller>apps/api/src/pm/phases/phases.controller.ts</controller>
        <service>apps/api/src/pm/agents/checkpoint.service.ts</service>
        <description>Update a checkpoint (typically to mark as COMPLETED)</description>
        <rbac>Roles: owner, admin, member</rbac>

        <controller-implementation>
          <![CDATA[
@Put(':id/checkpoints/:checkpointId')
@Roles('owner', 'admin', 'member')
@ApiOperation({ summary: 'Update a checkpoint' })
async updateCheckpoint(
  @CurrentWorkspace() workspaceId: string,
  @CurrentUser() user: User,
  @Param('checkpointId') checkpointId: string,
  @Body() dto: UpdateCheckpointDto,
): Promise<PhaseCheckpoint> {
  return this.checkpointService.updateCheckpoint(
    workspaceId,
    checkpointId,
    user.id,
    dto
  );
}
          ]]>
        </controller-implementation>
      </endpoint>
    </new-endpoints-required>
  </api-endpoints>

  <!-- ========================================
       BACKEND SERVICE IMPLEMENTATION
       ======================================== -->
  <backend-implementation>
    <new-service-file>
      <name>CheckpointService</name>
      <location>apps/api/src/pm/agents/checkpoint.service.ts (NEW FILE)</location>
      <dependencies>
        - PrismaService (database access)
        - NotificationService (reminder delivery)
        - EventBusService (event publishing)
      </dependencies>

      <service-structure>
        <![CDATA[
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '@/shared/prisma/prisma.service';
import { NotificationService } from '@/notifications/notification.service';
import { EventBusService } from '@/event-bus/event-bus.service';

@Injectable()
export class CheckpointService {
  constructor(
    private prisma: PrismaService,
    private notifications: NotificationService,
    private eventBus: EventBusService,
  ) {}

  /**
   * Create a new phase checkpoint
   */
  async createCheckpoint(
    workspaceId: string,
    phaseId: string,
    userId: string,
    dto: CreateCheckpointDto,
  ): Promise<PhaseCheckpoint> {
    // Verify phase ownership
    const phase = await this.verifyPhaseAccess(workspaceId, phaseId, userId);

    const checkpoint = await this.prisma.phaseCheckpoint.create({
      data: {
        phaseId,
        name: dto.name,
        description: dto.description,
        checkpointDate: dto.checkpointDate,
        remindAt3Days: dto.remindAt3Days ?? true,
        remindAt1Day: dto.remindAt1Day ?? true,
        remindAtDayOf: dto.remindAtDayOf ?? true,
      },
    });

    await this.eventBus.publish('pm.checkpoint.created', {
      checkpointId: checkpoint.id,
      phaseId,
      projectId: phase.projectId,
      userId,
    });

    return checkpoint;
  }

  /**
   * List checkpoints for a phase
   */
  async listCheckpoints(
    workspaceId: string,
    phaseId: string,
  ): Promise<PhaseCheckpoint[]> {
    await this.verifyPhaseAccess(workspaceId, phaseId);

    return this.prisma.phaseCheckpoint.findMany({
      where: { phaseId },
      orderBy: { checkpointDate: 'asc' },
    });
  }

  /**
   * Update checkpoint status
   */
  async updateCheckpoint(
    workspaceId: string,
    checkpointId: string,
    userId: string,
    dto: UpdateCheckpointDto,
  ): Promise<PhaseCheckpoint> {
    const checkpoint = await this.verifyCheckpointAccess(
      workspaceId,
      checkpointId,
      userId
    );

    const updated = await this.prisma.phaseCheckpoint.update({
      where: { id: checkpointId },
      data: {
        ...(dto.name && { name: dto.name }),
        ...(dto.description !== undefined && { description: dto.description }),
        ...(dto.checkpointDate && { checkpointDate: dto.checkpointDate }),
        ...(dto.status && {
          status: dto.status,
          ...(dto.status === 'COMPLETED' && { completedAt: new Date() }),
        }),
      },
    });

    if (dto.status === 'COMPLETED') {
      await this.eventBus.publish('pm.checkpoint.completed', {
        checkpointId: checkpoint.id,
        phaseId: checkpoint.phaseId,
        userId,
      });
    }

    return updated;
  }

  /**
   * Send checkpoint reminders (called by cron job)
   */
  async sendReminders(): Promise<void> {
    const now = new Date();
    const threeDaysFromNow = new Date(now.getTime() + 3 * 24 * 60 * 60 * 1000);
    const oneDayFromNow = new Date(now.getTime() + 1 * 24 * 60 * 60 * 1000);

    // 3-day reminders
    await this.sendReminderBatch(now, threeDaysFromNow, '3_days');

    // 1-day reminders
    await this.sendReminderBatch(now, oneDayFromNow, '1_day');

    // Day-of reminders
    await this.sendReminderBatch(now, now, 'day_of');
  }

  /**
   * Send a batch of reminders for a specific interval
   */
  private async sendReminderBatch(
    now: Date,
    targetDate: Date,
    interval: '3_days' | '1_day' | 'day_of',
  ): Promise<void> {
    const startOfDay = new Date(targetDate);
    startOfDay.setHours(0, 0, 0, 0);

    const endOfDay = new Date(targetDate);
    endOfDay.setHours(23, 59, 59, 999);

    // Build where clause based on interval
    const whereClause: any = {
      checkpointDate: {
        gte: startOfDay,
        lte: endOfDay,
      },
      status: 'PENDING',
    };

    // Filter by reminder preference and sent status
    if (interval === '3_days') {
      whereClause.remindAt3Days = true;
      whereClause.reminder3DaysSent = false;
    } else if (interval === '1_day') {
      whereClause.remindAt1Day = true;
      whereClause.reminder1DaySent = false;
    } else {
      whereClause.remindAtDayOf = true;
      whereClause.reminderDayOfSent = false;
    }

    const checkpoints = await this.prisma.phaseCheckpoint.findMany({
      where: whereClause,
      include: {
        phase: {
          include: {
            project: true,
          },
        },
      },
    });

    for (const checkpoint of checkpoints) {
      try {
        await this.sendCheckpointReminder(checkpoint, interval);
      } catch (error) {
        this.logger.error(
          `Failed to send reminder for checkpoint ${checkpoint.id}`,
          error,
        );
        // Continue processing other checkpoints
      }
    }
  }

  /**
   * Send reminder notification for a single checkpoint
   */
  private async sendCheckpointReminder(
    checkpoint: PhaseCheckpointWithPhase,
    interval: '3_days' | '1_day' | 'day_of',
  ): Promise<void> {
    const phase = checkpoint.phase;
    const project = phase.project;

    // Get outstanding items for this phase
    const outstandingItems = await this.getOutstandingItems(phase.id);

    // Generate suggested actions (optional - can be enhanced with Scope agent)
    const suggestedActions = this.generateSuggestedActions(outstandingItems);

    // Determine message based on interval
    const intervalText =
      interval === '3_days'
        ? 'in 3 days'
        : interval === '1_day'
        ? 'tomorrow'
        : 'today';

    const message = `Checkpoint reminder: "${checkpoint.name}" is ${intervalText} (${this.formatDate(checkpoint.checkpointDate)})`;

    // Send notification to project team
    await this.notifications.send({
      workspaceId: project.workspaceId,
      userId: project.ownerId, // Send to project owner (can be enhanced to send to all team members)
      type: 'checkpoint_reminder',
      title: `Checkpoint: ${checkpoint.name}`,
      message,
      data: {
        checkpointId: checkpoint.id,
        phaseId: phase.id,
        projectId: project.id,
        phaseName: phase.name,
        outstandingItems: outstandingItems.summary,
        suggestedActions,
      },
      actions: [
        {
          label: 'Open Phase',
          url: `/pm/phases/${phase.id}`,
        },
      ],
    });

    // Mark reminder as sent
    const updateData: any = {};
    if (interval === '3_days') updateData.reminder3DaysSent = true;
    if (interval === '1_day') updateData.reminder1DaySent = true;
    if (interval === 'day_of') updateData.reminderDayOfSent = true;

    await this.prisma.phaseCheckpoint.update({
      where: { id: checkpoint.id },
      data: updateData,
    });

    // Publish event
    await this.eventBus.publish('pm.checkpoint.reminder_sent', {
      checkpointId: checkpoint.id,
      phaseId: phase.id,
      projectId: project.id,
      interval,
    });
  }

  /**
   * Get outstanding items for a phase (incomplete tasks, blockers, etc.)
   */
  private async getOutstandingItems(phaseId: string) {
    const incompleteTasks = await this.prisma.task.count({
      where: {
        phaseId,
        status: { notIn: ['DONE', 'CANCELLED'] },
      },
    });

    const blockedTasks = await this.prisma.task.count({
      where: {
        phaseId,
        status: 'BLOCKED',
      },
    });

    const overdueTasks = await this.prisma.task.count({
      where: {
        phaseId,
        dueDate: { lt: new Date() },
        status: { notIn: ['DONE', 'CANCELLED'] },
      },
    });

    return {
      summary: `${incompleteTasks} incomplete tasks, ${blockedTasks} blocked, ${overdueTasks} overdue`,
      incompleteTasks,
      blockedTasks,
      overdueTasks,
    };
  }

  /**
   * Generate suggested actions based on outstanding items
   */
  private generateSuggestedActions(
    outstandingItems: OutstandingItems,
  ): string[] {
    const actions: string[] = [];

    if (outstandingItems.blockedTasks > 0) {
      actions.push(`Unblock ${outstandingItems.blockedTasks} blocked tasks`);
    }

    if (outstandingItems.overdueTasks > 0) {
      actions.push(`Review ${outstandingItems.overdueTasks} overdue tasks`);
    }

    if (outstandingItems.incompleteTasks > 0) {
      actions.push(`Complete remaining ${outstandingItems.incompleteTasks} tasks`);
    }

    if (actions.length === 0) {
      actions.push('Phase on track - no immediate actions needed');
    }

    return actions;
  }

  private formatDate(date: Date): string {
    return new Intl.DateTimeFormat('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric',
    }).format(date);
  }

  private async verifyPhaseAccess(
    workspaceId: string,
    phaseId: string,
    userId?: string,
  ) {
    const phase = await this.prisma.phase.findFirst({
      where: {
        id: phaseId,
        project: { workspaceId },
      },
      include: { project: true },
    });

    if (!phase) {
      throw new NotFoundException('Phase not found');
    }

    return phase;
  }

  private async verifyCheckpointAccess(
    workspaceId: string,
    checkpointId: string,
    userId: string,
  ) {
    const checkpoint = await this.prisma.phaseCheckpoint.findFirst({
      where: {
        id: checkpointId,
        phase: {
          project: { workspaceId },
        },
      },
      include: {
        phase: {
          include: { project: true },
        },
      },
    });

    if (!checkpoint) {
      throw new NotFoundException('Checkpoint not found');
    }

    return checkpoint;
  }
}
        ]]>
      </service-structure>
    </new-service-file>

    <new-cron-file>
      <name>CheckpointReminderCron</name>
      <location>apps/api/src/pm/agents/checkpoint.cron.ts (NEW FILE)</location>

      <cron-implementation>
        <![CDATA[
import { Injectable, Logger } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { CheckpointService } from './checkpoint.service';

@Injectable()
export class CheckpointReminderCron {
  private readonly logger = new Logger(CheckpointReminderCron.name);

  constructor(private checkpointService: CheckpointService) {}

  @Cron(CronExpression.EVERY_DAY_AT_8AM)
  async sendCheckpointReminders() {
    this.logger.log('Running checkpoint reminder job...');

    try {
      await this.checkpointService.sendReminders();
      this.logger.log('Checkpoint reminders sent successfully');
    } catch (error) {
      this.logger.error('Failed to send checkpoint reminders', error);
    }
  }
}
        ]]>
      </cron-implementation>
    </new-cron-file>

    <module-registration>
      <location>apps/api/src/pm/pm.module.ts</location>
      <changes>
        <![CDATA[
// Add to imports
import { CheckpointService } from './agents/checkpoint.service';
import { CheckpointReminderCron } from './agents/checkpoint.cron';

// Add to providers array
providers: [
  // ... existing providers
  CheckpointService,
  CheckpointReminderCron,
],
        ]]>
      </changes>
    </module-registration>
  </backend-implementation>

  <!-- ========================================
       FRONTEND COMPONENTS
       ======================================== -->
  <frontend-components>
    <new-component>
      <name>PhaseCheckpointList</name>
      <location>apps/web/src/components/pm/phases/PhaseCheckpointList.tsx (NEW FILE)</location>
      <dependencies>
        - @/components/ui/card
        - @/components/ui/button
        - @tanstack/react-query
        - lucide-react (CheckCircle2, Circle, Calendar, Plus)
        - date-fns (formatDistanceToNow)
      </dependencies>

      <component-structure>
        <![CDATA[
'use client';

import { useState } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { CheckCircle2, Circle, Calendar, Plus } from 'lucide-react';
import { formatDistanceToNow } from 'date-fns';
import { CheckpointForm } from './CheckpointForm';
import { toast } from 'sonner';

interface PhaseCheckpointListProps {
  phaseId: string;
}

export function PhaseCheckpointList({ phaseId }: PhaseCheckpointListProps) {
  const [showForm, setShowForm] = useState(false);
  const queryClient = useQueryClient();

  const { data: checkpoints, isLoading } = useQuery({
    queryKey: ['checkpoints', phaseId],
    queryFn: () =>
      fetch(`/api/pm/phases/${phaseId}/checkpoints`).then(r => r.json()),
  });

  const markCompletedMutation = useMutation({
    mutationFn: (checkpointId: string) =>
      fetch(`/api/pm/phases/${phaseId}/checkpoints/${checkpointId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ status: 'COMPLETED' }),
      }).then(r => r.json()),
    onSuccess: () => {
      queryClient.invalidateQueries(['checkpoints', phaseId]);
      toast.success('Checkpoint marked as completed');
    },
    onError: () => {
      toast.error('Failed to mark checkpoint as completed');
    },
  });

  if (isLoading) return <div>Loading checkpoints...</div>;

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between">
        <CardTitle className="flex items-center gap-2">
          <Calendar className="w-5 h-5" />
          Phase Checkpoints
        </CardTitle>
        <Button
          variant="outline"
          size="sm"
          onClick={() => setShowForm(true)}
        >
          <Plus className="w-4 h-4 mr-2" />
          Add Checkpoint
        </Button>
      </CardHeader>
      <CardContent>
        {checkpoints && checkpoints.length > 0 ? (
          <div className="space-y-3">
            {checkpoints.map(checkpoint => (
              <div
                key={checkpoint.id}
                className={`flex items-start justify-between p-3 border rounded-lg ${
                  checkpoint.status === 'COMPLETED'
                    ? 'bg-muted/50 text-muted-foreground'
                    : ''
                }`}
              >
                <div className="flex items-start gap-3 flex-1">
                  <button
                    onClick={() =>
                      checkpoint.status === 'PENDING' &&
                      markCompletedMutation.mutate(checkpoint.id)
                    }
                    className="mt-0.5"
                    disabled={checkpoint.status === 'COMPLETED'}
                  >
                    {checkpoint.status === 'COMPLETED' ? (
                      <CheckCircle2 className="w-5 h-5 text-green-600" />
                    ) : (
                      <Circle className="w-5 h-5 text-muted-foreground hover:text-primary" />
                    )}
                  </button>

                  <div className="flex-1">
                    <div className="font-medium">{checkpoint.name}</div>
                    {checkpoint.description && (
                      <div className="text-sm text-muted-foreground mt-1">
                        {checkpoint.description}
                      </div>
                    )}
                    <div className="text-xs text-muted-foreground mt-2">
                      {new Date(checkpoint.checkpointDate).toLocaleDateString()}
                      {checkpoint.status === 'PENDING' && (
                        <span className="ml-2">
                          ({formatDistanceToNow(new Date(checkpoint.checkpointDate), { addSuffix: true })})
                        </span>
                      )}
                    </div>
                  </div>
                </div>
              </div>
            ))}
          </div>
        ) : (
          <div className="text-center text-muted-foreground py-8">
            No checkpoints defined for this phase.
            <br />
            <Button
              variant="link"
              onClick={() => setShowForm(true)}
              className="mt-2"
            >
              Add your first checkpoint
            </Button>
          </div>
        )}
      </CardContent>

      {showForm && (
        <CheckpointForm
          phaseId={phaseId}
          onClose={() => setShowForm(false)}
          onSuccess={() => {
            setShowForm(false);
            queryClient.invalidateQueries(['checkpoints', phaseId]);
          }}
        />
      )}
    </Card>
  );
}
        ]]>
      </component-structure>

      <styling-notes>
        - Use Card component for container
        - Flex layout for header with title + button
        - Space-y-3 for checkpoint list spacing
        - bg-muted/50 for completed checkpoints (visual distinction)
        - Circle icon for pending, CheckCircle2 for completed
        - formatDistanceToNow for countdown display
      </styling-notes>
    </new-component>

    <new-component>
      <name>CheckpointForm</name>
      <location>apps/web/src/components/pm/phases/CheckpointForm.tsx (NEW FILE)</location>
      <dependencies>
        - @/components/ui/dialog
        - @/components/ui/button
        - @/components/ui/input
        - @/components/ui/textarea
        - @/components/ui/label
        - @/components/ui/checkbox
        - @tanstack/react-query
      </dependencies>

      <component-structure>
        <![CDATA[
'use client';

import { useState } from 'react';
import { useMutation } from '@tanstack/react-query';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { Checkbox } from '@/components/ui/checkbox';
import { toast } from 'sonner';

interface CheckpointFormProps {
  phaseId: string;
  onClose: () => void;
  onSuccess: () => void;
}

export function CheckpointForm({
  phaseId,
  onClose,
  onSuccess,
}: CheckpointFormProps) {
  const [formData, setFormData] = useState({
    name: '',
    description: '',
    checkpointDate: '',
    remindAt3Days: true,
    remindAt1Day: true,
    remindAtDayOf: true,
  });

  const createMutation = useMutation({
    mutationFn: () =>
      fetch(`/api/pm/phases/${phaseId}/checkpoints`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData),
      }).then(r => {
        if (!r.ok) throw new Error('Failed to create checkpoint');
        return r.json();
      }),
    onSuccess: () => {
      toast.success('Checkpoint created successfully');
      onSuccess();
    },
    onError: () => {
      toast.error('Failed to create checkpoint');
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    createMutation.mutate();
  };

  return (
    <Dialog open onOpenChange={onClose}>
      <DialogContent className="max-w-md">
        <DialogHeader>
          <DialogTitle>Add Phase Checkpoint</DialogTitle>
        </DialogHeader>

        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <Label htmlFor="name">Checkpoint Name*</Label>
            <Input
              id="name"
              value={formData.name}
              onChange={e =>
                setFormData({ ...formData, name: e.target.value })
              }
              placeholder="e.g., Design Review Complete"
              required
            />
          </div>

          <div>
            <Label htmlFor="checkpointDate">Date*</Label>
            <Input
              id="checkpointDate"
              type="date"
              value={formData.checkpointDate}
              onChange={e =>
                setFormData({ ...formData, checkpointDate: e.target.value })
              }
              required
            />
          </div>

          <div>
            <Label htmlFor="description">Description</Label>
            <Textarea
              id="description"
              value={formData.description}
              onChange={e =>
                setFormData({ ...formData, description: e.target.value })
              }
              placeholder="Optional details about this checkpoint..."
              rows={3}
            />
          </div>

          <div className="space-y-2">
            <Label>Reminder Preferences</Label>
            <div className="space-y-2">
              <div className="flex items-center space-x-2">
                <Checkbox
                  id="remind3days"
                  checked={formData.remindAt3Days}
                  onCheckedChange={checked =>
                    setFormData({ ...formData, remindAt3Days: checked as boolean })
                  }
                />
                <label
                  htmlFor="remind3days"
                  className="text-sm cursor-pointer"
                >
                  Remind me 3 days before
                </label>
              </div>

              <div className="flex items-center space-x-2">
                <Checkbox
                  id="remind1day"
                  checked={formData.remindAt1Day}
                  onCheckedChange={checked =>
                    setFormData({ ...formData, remindAt1Day: checked as boolean })
                  }
                />
                <label
                  htmlFor="remind1day"
                  className="text-sm cursor-pointer"
                >
                  Remind me 1 day before
                </label>
              </div>

              <div className="flex items-center space-x-2">
                <Checkbox
                  id="reminddayof"
                  checked={formData.remindAtDayOf}
                  onCheckedChange={checked =>
                    setFormData({ ...formData, remindAtDayOf: checked as boolean })
                  }
                />
                <label
                  htmlFor="reminddayof"
                  className="text-sm cursor-pointer"
                >
                  Remind me on the day
                </label>
              </div>
            </div>
          </div>

          <DialogFooter>
            <Button type="button" variant="outline" onClick={onClose}>
              Cancel
            </Button>
            <Button
              type="submit"
              disabled={createMutation.isPending}
            >
              {createMutation.isPending ? 'Creating...' : 'Create Checkpoint'}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}
        ]]>
      </component-structure>

      <styling-notes>
        - Use Dialog with max-w-md
        - Space-y-4 for form field spacing
        - Label + Input/Textarea pattern
        - Checkbox group with space-y-2
        - DialogFooter for action buttons
      </styling-notes>
    </new-component>

    <integration-with-phase-detail>
      <location>apps/web/src/app/(dashboard)/pm/phases/[id]/page.tsx</location>
      <changes>
        <![CDATA[
// Add import
import { PhaseCheckpointList } from '@/components/pm/phases/PhaseCheckpointList';

// Add to phase detail page layout (after phase tasks section)
<div className="mt-6">
  <PhaseCheckpointList phaseId={params.id} />
</div>
        ]]>
      </changes>
    </integration-with-phase-detail>
  </frontend-components>

  <!-- ========================================
       EVENT BUS INTEGRATION
       ======================================== -->
  <event-bus-integration>
    <new-event-types>
      <location>packages/shared/src/events/event-types.ts</location>
      <events>
        - PM_CHECKPOINT_CREATED: 'pm.checkpoint.created'
        - PM_CHECKPOINT_COMPLETED: 'pm.checkpoint.completed'
        - PM_CHECKPOINT_REMINDER_SENT: 'pm.checkpoint.reminder_sent'
      </events>
    </new-event-types>

    <event-payloads>
      <![CDATA[
// pm.checkpoint.created
{
  checkpointId: string;
  phaseId: string;
  projectId: string;
  userId: string;
}

// pm.checkpoint.completed
{
  checkpointId: string;
  phaseId: string;
  userId: string;
}

// pm.checkpoint.reminder_sent
{
  checkpointId: string;
  phaseId: string;
  projectId: string;
  interval: '3_days' | '1_day' | 'day_of';
}
      ]]>
    </event-payloads>
  </event-bus-integration>

  <!-- ========================================
       IMPLEMENTATION TASKS
       ======================================== -->
  <implementation-tasks>
    <database-tasks>
      <task>
        <name>Add sent tracking fields to PhaseCheckpoint model</name>
        <file>packages/db/prisma/schema.prisma</file>
        <steps>
          1. Add reminder3DaysSent, reminder1DaySent, reminderDayOfSent fields
          2. Run: npx prisma migrate dev --name add_checkpoint_reminder_sent_flags
          3. Run: npx prisma generate
        </steps>
      </task>
    </database-tasks>

    <backend-tasks>
      <task>
        <name>Create CheckpointService</name>
        <file>apps/api/src/pm/agents/checkpoint.service.ts</file>
        <steps>
          1. Create service class with constructor injections
          2. Implement createCheckpoint() method
          3. Implement listCheckpoints() method
          4. Implement updateCheckpoint() method
          5. Implement sendReminders() method (main cron logic)
          6. Implement sendReminderBatch() private method
          7. Implement sendCheckpointReminder() private method
          8. Implement getOutstandingItems() helper
          9. Implement generateSuggestedActions() helper
          10. Add workspace access verification methods
        </steps>
      </task>

      <task>
        <name>Create CheckpointReminderCron</name>
        <file>apps/api/src/pm/agents/checkpoint.cron.ts</file>
        <steps>
          1. Create cron class with @Cron decorator
          2. Set schedule to EVERY_DAY_AT_8AM
          3. Inject CheckpointService
          4. Add error handling and logging
        </steps>
      </task>

      <task>
        <name>Create DTOs</name>
        <file>apps/api/src/pm/agents/dto/checkpoint.dto.ts</file>
        <steps>
          1. Create CreateCheckpointDto class
          2. Create UpdateCheckpointDto class
          3. Add validation decorators
        </steps>
      </task>

      <task>
        <name>Extend PhasesController</name>
        <file>apps/api/src/pm/phases/phases.controller.ts</file>
        <steps>
          1. Import CheckpointService and DTOs
          2. Add GET /api/pm/phases/:id/checkpoints endpoint
          3. Add POST /api/pm/phases/:id/checkpoints endpoint
          4. Add PUT /api/pm/phases/:id/checkpoints/:checkpointId endpoint
          5. Add RBAC guards (owner, admin, member)
        </steps>
      </task>

      <task>
        <name>Register services in PmModule</name>
        <file>apps/api/src/pm/pm.module.ts</file>
        <steps>
          1. Import CheckpointService and CheckpointReminderCron
          2. Add to providers array
        </steps>
      </task>

      <task>
        <name>Add event types</name>
        <file>packages/shared/src/events/event-types.ts</file>
        <steps>
          1. Add PM_CHECKPOINT_CREATED event type
          2. Add PM_CHECKPOINT_COMPLETED event type
          3. Add PM_CHECKPOINT_REMINDER_SENT event type
        </steps>
      </task>
    </backend-tasks>

    <frontend-tasks>
      <task>
        <name>Create PhaseCheckpointList component</name>
        <file>apps/web/src/components/pm/phases/PhaseCheckpointList.tsx</file>
        <steps>
          1. Create component with TanStack Query
          2. Fetch checkpoints from API
          3. Display checkpoints in chronological order
          4. Show countdown with formatDistanceToNow
          5. Add "Mark as Completed" button
          6. Add "Add Checkpoint" button
          7. Implement modal state management
        </steps>
      </task>

      <task>
        <name>Create CheckpointForm component</name>
        <file>apps/web/src/components/pm/phases/CheckpointForm.tsx</file>
        <steps>
          1. Create Dialog modal component
          2. Add form fields (name, date, description)
          3. Add reminder preference checkboxes
          4. Implement form validation
          5. Add submit mutation
          6. Handle success/error states
        </steps>
      </task>

      <task>
        <name>Integrate with phase detail page</name>
        <file>apps/web/src/app/(dashboard)/pm/phases/[id]/page.tsx</file>
        <steps>
          1. Import PhaseCheckpointList
          2. Add component to page layout
          3. Place after tasks section
        </steps>
      </task>
    </frontend-tasks>

    <testing-tasks>
      <task>
        <name>Unit tests - CheckpointService</name>
        <file>apps/api/src/pm/agents/checkpoint.service.spec.ts</file>
        <test-cases>
          - createCheckpoint() creates checkpoint with reminder preferences
          - listCheckpoints() returns checkpoints for phase
          - updateCheckpoint() updates status and marks completedAt
          - sendReminders() finds checkpoints in correct date ranges
          - sendReminderBatch() sends reminders only for unsent intervals
          - getOutstandingItems() calculates incomplete/blocked/overdue tasks
          - generateSuggestedActions() returns actionable next steps
          - Workspace isolation enforced in all methods
        </test-cases>
      </task>

      <task>
        <name>Unit tests - Frontend components</name>
        <files>
          - apps/web/src/components/pm/phases/PhaseCheckpointList.test.tsx
          - apps/web/src/components/pm/phases/CheckpointForm.test.tsx
        </files>
        <test-cases>
          - PhaseCheckpointList renders checkpoints in chronological order
          - PhaseCheckpointList displays correct status icons (pending, completed)
          - PhaseCheckpointList calculates countdown correctly
          - CheckpointForm validates required fields (name, date)
          - CheckpointForm submits with correct reminder preferences
          - Mark as completed mutation updates checkpoint status
        </test-cases>
      </task>

      <task>
        <name>Integration tests - API endpoints</name>
        <file>apps/api/test/pm/agents/checkpoint.e2e-spec.ts</file>
        <test-cases>
          - POST /api/pm/phases/:id/checkpoints creates checkpoint successfully
          - GET /api/pm/phases/:id/checkpoints returns checkpoints for phase
          - PUT /api/pm/phases/:id/checkpoints/:id updates checkpoint status
          - Unauthorized users cannot create/update checkpoints (403)
          - Phase not in workspace returns 404
        </test-cases>
      </task>

      <task>
        <name>Integration tests - Cron job</name>
        <file>apps/api/test/pm/agents/checkpoint-cron.e2e-spec.ts</file>
        <test-cases>
          - Checkpoint reminder cron runs daily at 8 AM
          - Sends 3-day reminders for checkpoints 3 days away
          - Sends 1-day reminders for checkpoints 1 day away
          - Sends day-of reminders for checkpoints today
          - Does not send duplicate reminders (checks sent flags)
          - Marks reminder as sent after delivery
        </test-cases>
      </task>
    </testing-tasks>
  </implementation-tasks>

  <!-- ========================================
       KEY FILES TO CREATE/MODIFY
       ======================================== -->
  <file-changes>
    <new-files>
      <file>apps/api/src/pm/agents/checkpoint.service.ts</file>
      <file>apps/api/src/pm/agents/checkpoint.cron.ts</file>
      <file>apps/api/src/pm/agents/dto/checkpoint.dto.ts</file>
      <file>apps/web/src/components/pm/phases/PhaseCheckpointList.tsx</file>
      <file>apps/web/src/components/pm/phases/CheckpointForm.tsx</file>
      <file>apps/api/src/pm/agents/checkpoint.service.spec.ts</file>
      <file>apps/web/src/components/pm/phases/PhaseCheckpointList.test.tsx</file>
      <file>apps/web/src/components/pm/phases/CheckpointForm.test.tsx</file>
      <file>apps/api/test/pm/agents/checkpoint.e2e-spec.ts</file>
      <file>apps/api/test/pm/agents/checkpoint-cron.e2e-spec.ts</file>
    </new-files>

    <modified-files>
      <file>packages/db/prisma/schema.prisma (add reminder sent tracking fields)</file>
      <file>apps/api/src/pm/phases/phases.controller.ts (add checkpoint endpoints)</file>
      <file>apps/api/src/pm/pm.module.ts (register services)</file>
      <file>apps/web/src/app/(dashboard)/pm/phases/[id]/page.tsx (add PhaseCheckpointList)</file>
      <file>packages/shared/src/events/event-types.ts (add checkpoint events)</file>
    </modified-files>
  </file-changes>

  <!-- ========================================
       CRITICAL NOTES
       ======================================== -->
  <critical-notes>
    <note priority="high">
      <title>Sent Flag Tracking</title>
      <description>
        MUST add reminder3DaysSent, reminder1DaySent, reminderDayOfSent fields to
        PhaseCheckpoint model to prevent duplicate reminders. Check both preference
        (remindAt3Days) AND sent status (reminder3DaysSent) in query.
      </description>
    </note>

    <note priority="high">
      <title>Date Range Calculation</title>
      <description>
        Use startOfDay (00:00:00) and endOfDay (23:59:59) to handle timezone issues.
        Reminders sent at 8 AM UTC - consider future enhancement for user timezones.
      </description>
    </note>

    <note priority="high">
      <title>Workspace Isolation</title>
      <description>
        All database queries MUST enforce workspace scoping. Verify that checkpoint.phase.project.workspaceId
        matches workspaceId before processing any operations.
      </description>
    </note>

    <note priority="medium">
      <title>Error Handling in Cron</title>
      <description>
        Process checkpoints in loop with individual try/catch. If one checkpoint fails,
        continue processing remaining checkpoints. Log errors but don't throw (prevents cron crash).
      </description>
    </note>

    <note priority="medium">
      <title>Outstanding Items Calculation</title>
      <description>
        Count incomplete tasks (not DONE/CANCELLED), blocked tasks (status=BLOCKED),
        and overdue tasks (dueDate &lt; now, not DONE/CANCELLED). Display summary in notification.
      </description>
    </note>

    <note priority="low">
      <title>Future Enhancement: Scope Agent Integration</title>
      <description>
        Current implementation uses simple heuristics for suggested actions. Future:
        invoke Scope agent to analyze phase context and provide smarter suggestions.
      </description>
    </note>

    <note priority="low">
      <title>Notification Recipient</title>
      <description>
        Current implementation sends to project owner only. Future enhancement:
        send to all project team members with user-level notification preferences.
      </description>
    </note>
  </critical-notes>

  <!-- ========================================
       REFERENCE DOCUMENTATION
       ======================================== -->
  <references>
    <doc type="story">
      <path>docs/modules/bm-pm/stories/pm-05-3-scope-checkpoint-reminders.md</path>
      <description>Full story specification with technical requirements</description>
    </doc>

    <doc type="epic-tech-spec">
      <path>docs/modules/bm-pm/epics/epic-pm-05-tech-spec.md</path>
      <description>Technical specification for Epic PM-05 (Scope, Pulse, Herald)</description>
    </doc>

    <doc type="previous-story-context">
      <path>docs/modules/bm-pm/stories/pm-05-2-scope-phase-transition-flow.context.xml</path>
      <description>Context from PM-05.2 - provides phase transition pattern</description>
    </doc>

    <doc type="existing-pattern">
      <path>apps/api/src/kb/verification/verification-expiry.job.ts</path>
      <description>Example: Cron job pattern with daily scheduling</description>
    </doc>

    <doc type="existing-pattern">
      <path>apps/api/src/ai-providers/token-reset.service.ts</path>
      <description>Example: Cron service with multiple schedules</description>
    </doc>

    <doc type="database-schema">
      <path>packages/db/prisma/schema.prisma</path>
      <description>Current database schema with PhaseCheckpoint model (lines 1403-1429)</description>
    </doc>
  </references>

  <!-- ========================================
       EXAMPLE SCENARIOS
       ======================================== -->
  <example-scenarios>
    <scenario name="Create Checkpoint and Receive Reminders">
      <description>User creates checkpoint and receives automated reminders</description>
      <steps>
        1. User navigates to phase detail page
        2. User clicks "Add Checkpoint" button
        3. CheckpointForm modal opens
        4. User enters:
           - Name: "Design Review Complete"
           - Date: 2025-12-25 (7 days from now)
           - Description: "All designs approved by stakeholders"
           - Reminder preferences: All checked (3 days, 1 day, day-of)
        5. User clicks "Create Checkpoint"
        6. Frontend calls POST /api/pm/phases/phase_abc123/checkpoints
        7. Backend creates checkpoint with status=PENDING, all sent flags=false
        8. Frontend refreshes checkpoint list
        9. Checkpoint appears in list with countdown "in 7 days"

        10. [3 days before - Dec 22 at 8 AM UTC]
        11. Cron job runs, finds checkpoint with checkpointDate=Dec 25
        12. Backend checks: remindAt3Days=true, reminder3DaysSent=false
        13. Backend sends notification to project owner
        14. Notification contains:
            - Title: "Checkpoint: Design Review Complete"
            - Message: "Checkpoint reminder: 'Design Review Complete' is in 3 days (Dec 25, 2025)"
            - Outstanding items: "3 incomplete tasks, 0 blocked, 1 overdue"
            - Suggested actions: ["Review 1 overdue task", "Complete remaining 3 tasks"]
            - Action: "Open Phase"  /pm/phases/phase_abc123
        15. Backend updates checkpoint: reminder3DaysSent=true

        16. [1 day before - Dec 24 at 8 AM UTC]
        17. Cron job runs, finds checkpoint
        18. Backend checks: remindAt1Day=true, reminder1DaySent=false
        19. Backend sends notification: "in 1 day"
        20. Backend updates: reminder1DaySent=true

        21. [Day-of - Dec 25 at 8 AM UTC]
        22. Cron job runs, finds checkpoint
        23. Backend checks: remindAtDayOf=true, reminderDayOfSent=false
        24. Backend sends notification: "today"
        25. Backend updates: reminderDayOfSent=true
      </steps>
    </scenario>

    <scenario name="Mark Checkpoint as Completed">
      <description>User marks checkpoint as completed</description>
      <steps>
        1. User views phase detail page with checkpoint list
        2. User clicks Circle icon next to "Design Review Complete"
        3. Frontend calls PUT /api/pm/phases/:id/checkpoints/:checkpointId
           Body: { status: 'COMPLETED' }
        4. Backend updates checkpoint:
           - status: COMPLETED
           - completedAt: now
        5. Backend publishes event: pm.checkpoint.completed
        6. Frontend refreshes checkpoint list
        7. Checkpoint now shows:
           - CheckCircle2 icon (green checkmark)
           - bg-muted/50 background
           - text-muted-foreground color
        8. Future reminders will NOT be sent (status != PENDING)
      </steps>
    </scenario>

    <scenario name="Disable Reminders">
      <description>User creates checkpoint without reminders</description>
      <steps>
        1. User opens CheckpointForm modal
        2. User enters checkpoint details
        3. User unchecks all reminder preferences:
           - remindAt3Days: false
           - remindAt1Day: false
           - remindAtDayOf: false
        4. User clicks "Create Checkpoint"
        5. Backend creates checkpoint with all remindAt* flags = false
        6. Cron job runs but skips this checkpoint (remindAt3Days=false)
        7. No reminders sent for this checkpoint
      </steps>
    </scenario>

    <scenario name="Duplicate Prevention">
      <description>Cron job runs multiple times but only sends once</description>
      <steps>
        1. Checkpoint exists with checkpointDate=Dec 22
        2. Dec 19 at 8 AM: Cron runs
        3. Backend finds checkpoint (3 days away)
        4. Checks: remindAt3Days=true, reminder3DaysSent=false
        5. Sends notification
        6. Updates: reminder3DaysSent=true

        7. [Hypothetical: cron runs again same day]
        8. Backend finds checkpoint (3 days away)
        9. Checks: remindAt3Days=true, reminder3DaysSent=true  Already sent!
        10. Skips sending (duplicate prevention)
      </steps>
    </scenario>
  </example-scenarios>
</story-context>
