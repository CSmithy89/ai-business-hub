<?xml version="1.0" encoding="UTF-8"?>
<story-context>
  <story>
    <id>05-3-implement-event-subscriber</id>
    <title>Implement Event Subscriber</title>
    <epic>EPIC-05 - Event Bus Infrastructure</epic>
    <status>ready-for-dev</status>
    <points>3</points>
    <priority>P0</priority>
  </story>

  <dependencies>
    <dependency type="completed-story">
      <story-id>05-1-set-up-redis-streams-infrastructure</story-id>
      <description>Redis Streams infrastructure and consumer groups are set up</description>
      <provides>
        <item>Redis connection via RedisProvider</item>
        <item>Consumer group 'hyvve-platform' created for hyvve:events:main stream</item>
        <item>Stream constants (STREAMS, CONSUMER_GROUP, CONSUMER_CONFIG)</item>
        <item>EventsModule with setupStreams() on module init</item>
      </provides>
    </dependency>
    <dependency type="completed-story">
      <story-id>05-2-implement-event-publisher</story-id>
      <description>Event publishing to Redis Streams is working</description>
      <provides>
        <item>EventPublisherService with publish() and publishBatch() methods</item>
        <item>BaseEvent structure in packages/shared/src/types/events.ts</item>
        <item>EventMetadata Prisma model with status tracking</item>
        <item>Event serialization format (JSON in Redis stream)</item>
      </provides>
    </dependency>
    <dependency type="infrastructure">
      <name>NestJS DiscoveryService</name>
      <package>@nestjs/core</package>
      <description>Used to discover all providers in the application and find @EventSubscriber decorated methods</description>
    </dependency>
    <dependency type="infrastructure">
      <name>NestJS Reflector</name>
      <package>@nestjs/core</package>
      <description>Used to read metadata from @EventSubscriber decorator</description>
    </dependency>
    <dependency type="infrastructure">
      <name>Redis XREADGROUP</name>
      <description>Redis Streams command for consuming events from consumer group</description>
      <usage>Blocking read with 5s timeout, batch size of 10 events</usage>
    </dependency>
  </dependencies>

  <implementation-guidance>
    <overview>
      This story implements the "read" side of the event bus - consuming events from Redis Streams and dispatching them to handler methods decorated with @EventSubscriber. The consumer service runs a continuous loop using XREADGROUP to read from the stream and calls matching handlers based on pattern matching.
    </overview>

    <architecture>
      <consumer-loop>
        <description>Continuous XREADGROUP loop that blocks waiting for new events</description>
        <flow>
          1. XREADGROUP (blocking, 5s timeout, batch size 10)
          2. Deserialize events from Redis
          3. For each event:
             a. Find matching handlers by pattern
             b. Sort handlers by priority (ascending)
             c. Execute handlers sequentially
             d. On success: XACK + update EventMetadata to COMPLETED
             e. On error: Pass to EventRetryService (Story 05-4)
          4. Continue loop (while running = true)
        </flow>
        <graceful-shutdown>
          Set running = false in onModuleDestroy, wait 6s for current batch to finish
        </graceful-shutdown>
      </consumer-loop>

      <handler-discovery>
        <description>Use NestJS DiscoveryService to find all @EventSubscriber decorated methods</description>
        <flow>
          1. Call discoveryService.getProviders()
          2. For each provider:
             a. Get instance and prototype
             b. Find all methods on prototype
             c. Use Reflector to read EVENT_SUBSCRIBER_METADATA
             d. Register method as handler if metadata exists
          3. Store handlers in Map&lt;pattern, EventHandlerInfo[]&gt;
          4. Log number of discovered handlers
        </flow>
        <timing>Called in onModuleInit before starting consumer loop</timing>
      </handler-discovery>

      <pattern-matching>
        <description>Match event types against handler patterns</description>
        <rules>
          <rule pattern="*">Matches all events</rule>
          <rule pattern="approval.*">Matches all events starting with "approval." (wildcard suffix)</rule>
          <rule pattern="approval.item.approved">Exact match only</rule>
        </rules>
        <implementation>
          if (pattern === '*') return true;
          if (pattern.endsWith('.*')) {
            const prefix = pattern.slice(0, -2);
            return eventType.startsWith(prefix + '.');
          }
          return eventType === pattern;
        </implementation>
      </pattern-matching>

      <handler-priority>
        <description>Handlers execute in priority order (lower number = higher priority)</description>
        <default>100</default>
        <sorting>Sort handlers by priority ascending before execution</sorting>
        <example>
          Priority 1 handler runs first
          Priority 100 handler runs second
          Priority 999 handler runs last
        </example>
      </handler-priority>
    </architecture>

    <files-to-create>
      <file>
        <path>apps/api/src/events/decorators/event-subscriber.decorator.ts</path>
        <description>@EventSubscriber() decorator using SetMetadata</description>
        <exports>
          - EVENT_SUBSCRIBER_METADATA constant
          - EventSubscriberOptions interface
          - EventSubscriber decorator function
        </exports>
        <implementation-notes>
          Use SetMetadata from @nestjs/common
          Default priority: 100
          Default maxRetries: 3
          Pattern is required, other options optional
        </implementation-notes>
      </file>

      <file>
        <path>apps/api/src/events/interfaces/event-handler.interface.ts</path>
        <description>Interface for registered event handlers</description>
        <exports>
          - EventHandlerInfo interface with pattern, priority, maxRetries, instanceRef, methodName, execute()
        </exports>
        <implementation-notes>
          execute: (event: BaseEvent) =&gt; Promise&lt;void&gt;
          instanceRef: any (the service/controller instance)
          methodName: string (for logging/debugging)
        </implementation-notes>
      </file>

      <file>
        <path>apps/api/src/events/event-consumer.service.ts</path>
        <description>Main consumer service with XREADGROUP loop</description>
        <dependencies>
          - RedisProvider (inject for Redis access)
          - DiscoveryService from @nestjs/core
          - Reflector from @nestjs/core
          - PrismaService (for EventMetadata updates)
          - Logger from @nestjs/common
        </dependencies>
        <lifecycle>
          onModuleInit: Discover handlers, start consumer loop
          onModuleDestroy: Set running=false, wait for graceful shutdown
        </lifecycle>
        <methods>
          - discoverHandlers(): Find all @EventSubscriber methods
          - consumeLoop(): Main XREADGROUP loop
          - processEvent(streamId, event): Process single event
          - findMatchingHandlers(eventType): Get handlers for event type
          - matchesPattern(eventType, pattern): Pattern matching logic
          - updateEventStatus(eventId, status): Update EventMetadata
          - handleError(streamId, event, handler, error): Error handling (Story 05-4)
        </methods>
        <state>
          - handlers: Map&lt;string, EventHandlerInfo[]&gt; (keyed by pattern)
          - running: boolean (for graceful shutdown)
          - consumerName: string (from CONSUMER_CONFIG.NAME)
        </state>
      </file>

      <file>
        <path>apps/api/src/events/event-consumer.service.spec.ts</path>
        <description>Unit tests for EventConsumerService</description>
        <test-cases>
          - Decorator stores metadata correctly
          - Handler discovery finds decorated methods
          - Pattern matching: exact matches
          - Pattern matching: wildcard patterns (approval.*, *)
          - Handlers called in priority order
          - Multiple handlers receive same event
          - XACK called after successful processing
          - Failed handlers trigger error handling
        </test-cases>
      </file>
    </files-to-create>

    <files-to-modify>
      <file>
        <path>apps/api/src/events/events.module.ts</path>
        <changes>
          - Import DiscoveryModule from @nestjs/core
          - Add EventConsumerService to providers
          - Import DiscoveryModule in imports array
        </changes>
        <implementation-notes>
          DiscoveryModule provides DiscoveryService for handler discovery
          EventConsumerService will start automatically via onModuleInit
        </implementation-notes>
      </file>

      <file>
        <path>apps/api/src/events/index.ts</path>
        <changes>
          - Export EventSubscriber decorator
          - Export EventConsumerService
          - Export EventHandlerInfo interface
        </changes>
        <implementation-notes>
          Make decorator available for other modules to use
        </implementation-notes>
      </file>
    </files-to-modify>

    <redis-streams-commands>
      <command name="XREADGROUP">
        <syntax>
          XREADGROUP GROUP group-name consumer-name
          [COUNT count] [BLOCK milliseconds]
          STREAMS stream-name [stream-name ...] id [id ...]
        </syntax>
        <example>
          const messages = await redis.xreadgroup(
            'GROUP', 'hyvve-platform', 'consumer-worker-123',
            'COUNT', 10,
            'BLOCK', 5000,
            'STREAMS', 'hyvve:events:main', '&gt;'
          );
        </example>
        <notes>
          - '&gt;' means "only new messages not yet delivered"
          - BLOCK 5000 waits up to 5 seconds for new messages
          - COUNT 10 processes up to 10 events per batch
          - Returns null if timeout expires with no new messages
        </notes>
      </command>

      <command name="XACK">
        <syntax>XACK stream-name group-name message-id [message-id ...]</syntax>
        <example>
          await redis.xack('hyvve:events:main', 'hyvve-platform', streamId);
        </example>
        <notes>
          Call after successful handler execution
          Removes event from pending entries list
          Required for at-least-once delivery guarantee
        </notes>
      </command>
    </redis-streams-commands>

    <event-processing-flow>
      <step number="1">
        <name>XREADGROUP</name>
        <description>Block waiting for new events (5s timeout)</description>
        <code>
          const messages = await redis.xreadgroup(
            'GROUP', CONSUMER_GROUP, this.consumerName,
            'COUNT', CONSUMER_CONFIG.BATCH_SIZE,
            'BLOCK', CONSUMER_CONFIG.BLOCK_TIMEOUT_MS,
            'STREAMS', STREAMS.MAIN, '&gt;'
          );
        </code>
      </step>

      <step number="2">
        <name>Deserialize Events</name>
        <description>Extract and parse events from Redis response</description>
        <code>
          if (messages) {
            for (const [stream, entries] of messages) {
              for (const [id, fields] of entries) {
                const event = JSON.parse(fields[1]) as BaseEvent;
                await this.processEvent(id, event);
              }
            }
          }
        </code>
      </step>

      <step number="3">
        <name>Find Matching Handlers</name>
        <description>Get all handlers that match the event type pattern</description>
        <code>
          private findMatchingHandlers(eventType: string): EventHandlerInfo[] {
            const results: EventHandlerInfo[] = [];
            for (const [pattern, handlers] of this.handlers) {
              if (this.matchesPattern(eventType, pattern)) {
                results.push(...handlers);
              }
            }
            return results.sort((a, b) =&gt; a.priority - b.priority);
          }
        </code>
      </step>

      <step number="4">
        <name>Execute Handlers</name>
        <description>Call handlers sequentially in priority order</description>
        <code>
          for (const handler of matchingHandlers) {
            try {
              await this.updateEventStatus(event.id, 'PROCESSING');
              await handler.execute(event);
              await redis.xack(STREAMS.MAIN, CONSUMER_GROUP, streamId);
              await this.updateEventStatus(event.id, 'COMPLETED');
            } catch (error) {
              await this.handleError(streamId, event, handler, error);
            }
          }
        </code>
      </step>
    </event-processing-flow>

    <error-handling>
      <strategy>
        <description>
          Handler exceptions should NOT crash the consumer loop.
          Log error, update EventMetadata, and pass to EventRetryService (Story 05-4).
        </description>
        <implementation>
          try {
            await handler.execute(event);
          } catch (error) {
            this.logger.error({
              message: 'Event handler failed',
              eventId: event.id,
              eventType: event.type,
              handlerPattern: handler.pattern,
              error: error.message,
            });
            // Story 05-4 will implement retry logic
            await this.updateEventStatus(event.id, 'FAILED');
          }
        </implementation>
      </strategy>

      <redis-connection-errors>
        <description>If XREADGROUP fails due to Redis connection issue</description>
        <implementation>
          catch (error) {
            this.logger.error('Error in consumer loop', error);
            await this.sleep(1000); // Backoff 1 second
            // Continue loop - don't crash
          }
        </implementation>
      </redis-connection-errors>
    </error-handling>

    <testing-guidance>
      <unit-tests>
        <test>
          <name>Decorator stores metadata</name>
          <description>Verify @EventSubscriber stores pattern and options in metadata</description>
          <approach>Use Reflector to read metadata from decorated method</approach>
        </test>

        <test>
          <name>Handler discovery</name>
          <description>Mock DiscoveryService to return test providers with decorated methods</description>
          <approach>Verify handlers registered in internal Map</approach>
        </test>

        <test>
          <name>Pattern matching - exact</name>
          <description>Test matchesPattern with exact event type</description>
          <cases>
            approval.item.approved matches approval.item.approved
            approval.item.approved does NOT match approval.item.rejected
          </cases>
        </test>

        <test>
          <name>Pattern matching - wildcard</name>
          <description>Test wildcard patterns</description>
          <cases>
            approval.* matches approval.item.approved
            approval.* matches approval.item.rejected
            * matches any event type
            approval does NOT match approval.item.approved
          </cases>
        </test>

        <test>
          <name>Handler priority</name>
          <description>Register handlers with different priorities</description>
          <approach>Verify execution order matches priority (ascending)</approach>
        </test>

        <test>
          <name>Multiple handlers</name>
          <description>Multiple handlers with different patterns match same event</description>
          <approach>Verify all matching handlers are called</approach>
        </test>

        <test>
          <name>XACK called</name>
          <description>Mock Redis and verify XACK called after successful handler</description>
          <approach>expect(mockRedis.xack).toHaveBeenCalledWith(...)</approach>
        </test>

        <test>
          <name>Error handling</name>
          <description>Handler throws exception</description>
          <approach>Verify error logged, status updated to FAILED, consumer loop continues</approach>
        </test>
      </unit-tests>

      <integration-tests>
        <test>
          <name>End-to-end event flow</name>
          <description>Publish event, verify consumed by handler</description>
          <steps>
            1. Create test handler with @EventSubscriber
            2. Publish event via EventPublisherService
            3. Wait for handler to be called
            4. Verify handler received correct event
            5. Verify event acknowledged in Redis
          </steps>
        </test>

        <test>
          <name>Consumer recovery</name>
          <description>Consumer loop recovers from Redis errors</description>
          <steps>
            1. Simulate Redis connection error
            2. Verify consumer logs error and backs off
            3. Verify consumer resumes after backoff
          </steps>
        </test>
      </integration-tests>
    </testing-guidance>

    <example-usage>
      <example>
        <description>Simple event handler</description>
        <code><![CDATA[
@Injectable()
export class NotificationHandler {
  private readonly logger = new Logger(NotificationHandler.name);

  @EventSubscriber('approval.item.approved')
  async handleApprovalApproved(event: BaseEvent<ApprovalDecisionPayload>) {
    this.logger.log(`Approval ${event.data.approvalId} approved by ${event.data.decidedById}`);
    // Send notification logic here
  }
}
        ]]></code>
      </example>

      <example>
        <description>Wildcard pattern handler</description>
        <code><![CDATA[
@Injectable()
export class ApprovalLogger {
  private readonly logger = new Logger(ApprovalLogger.name);

  @EventSubscriber('approval.*', { priority: 1 })
  async logAllApprovalEvents(event: BaseEvent) {
    this.logger.log(`Approval event: ${event.type} - ${event.id}`);
  }
}
        ]]></code>
      </example>

      <example>
        <description>Catch-all analytics handler</description>
        <code><![CDATA[
@Injectable()
export class AnalyticsHandler {
  @EventSubscriber('*', { priority: 999 })
  async trackAllEvents(event: BaseEvent) {
    // Track all events for analytics (low priority)
    await this.analytics.track(event);
  }
}
        ]]></code>
      </example>

      <example>
        <description>Multiple handlers for same event</description>
        <code><![CDATA[
// Handler 1: High priority notification
@EventSubscriber('approval.item.escalated', { priority: 10 })
async notifyEscalation(event: BaseEvent<ApprovalEscalatedPayload>) {
  await this.notifications.send(event.data.escalatedToId, ...);
}

// Handler 2: Low priority audit log
@EventSubscriber('approval.item.escalated', { priority: 100 })
async auditEscalation(event: BaseEvent<ApprovalEscalatedPayload>) {
  await this.auditLog.record(event);
}
        ]]></code>
      </example>
    </example-usage>

    <performance-considerations>
      <batch-size>
        <value>10</value>
        <rationale>Balance between latency and throughput. Small enough for quick processing, large enough for efficiency.</rationale>
      </batch-size>

      <block-timeout>
        <value>5000ms</value>
        <rationale>Prevents busy-waiting, allows graceful shutdown within reasonable time.</rationale>
      </block-timeout>

      <handler-execution>
        <mode>Sequential per event</mode>
        <rationale>Simplifies error handling and ensures handler order. Parallel execution can be added in future if needed.</rationale>
      </handler-execution>

      <consumer-group>
        <name>hyvve-platform</name>
        <rationale>Multiple app instances share this group, distributing event load automatically.</rationale>
      </consumer-group>

      <memory>
        <handlers-map>Store handlers in Map for O(1) lookup by pattern</handlers-map>
        <event-deserialization>Parse JSON only once per event</event-deserialization>
      </memory>
    </performance-considerations>

    <integration-points>
      <consumer-group-setup>
        <location>apps/api/src/events/events.module.ts</location>
        <method>setupStreams()</method>
        <description>Consumer group already created in Story 05-1</description>
      </consumer-group-setup>

      <event-metadata-model>
        <location>packages/db/prisma/schema.prisma</location>
        <model>EventMetadata</model>
        <fields>
          - eventId: Unique event identifier
          - streamId: Redis stream message ID
          - status: PENDING | PROCESSING | COMPLETED | FAILED | DLQ
          - attempts: Retry count (Story 05-4)
          - lastError: Last error message (Story 05-4)
        </fields>
      </event-metadata-model>

      <event-publisher>
        <location>apps/api/src/events/event-publisher.service.ts</location>
        <description>Used by integration tests to publish test events</description>
      </event-publisher>

      <redis-provider>
        <location>apps/api/src/events/redis.provider.ts</location>
        <method>getClient()</method>
        <description>Provides Redis client for XREADGROUP and XACK operations</description>
      </redis-provider>
    </integration-points>

    <graceful-shutdown>
      <description>
        On application shutdown, consumer must stop gracefully:
        1. Set running flag to false
        2. Current XREADGROUP call will timeout (max 5s)
        3. Current batch finishes processing (variable time)
        4. Wait 6 seconds total before module destroy completes
        5. Unacknowledged events remain in pending list for other consumers
      </description>
      <implementation>
        async onModuleDestroy() {
          this.logger.log('Stopping event consumer...');
          this.running = false;
          // Wait for current batch to finish (max 5s block + ~1s processing)
          await new Promise(resolve =&gt; setTimeout(resolve, 6000));
          this.logger.log('Event consumer stopped');
        }
      </implementation>
    </graceful-shutdown>

    <future-enhancements>
      <enhancement>
        <story>05-4</story>
        <description>Retry logic and DLQ - handleError() method will be implemented</description>
      </enhancement>
      <enhancement>
        <story>05-5</story>
        <description>Core platform events - actual handlers for approval/agent events</description>
      </enhancement>
      <enhancement>
        <story>05-6</story>
        <description>Event replay - ability to replay historical events</description>
      </enhancement>
      <enhancement>
        <story>05-7</story>
        <description>Monitoring dashboard - visibility into consumer lag and DLQ</description>
      </enhancement>
    </future-enhancements>
  </implementation-guidance>

  <existing-code-reference>
    <file>
      <path>apps/api/src/events/constants/streams.constants.ts</path>
      <key-exports>
        - STREAMS.MAIN: 'hyvve:events:main'
        - CONSUMER_GROUP: 'hyvve-platform'
        - CONSUMER_CONFIG.NAME: process.env.HOSTNAME || `consumer-${process.pid}`
        - CONSUMER_CONFIG.BLOCK_TIMEOUT_MS: 5000
        - CONSUMER_CONFIG.BATCH_SIZE: 10
      </key-exports>
    </file>

    <file>
      <path>apps/api/src/events/redis.provider.ts</path>
      <key-methods>
        - getClient(): Returns Redis client from BullMQ for stream operations
      </key-methods>
    </file>

    <file>
      <path>apps/api/src/events/event-publisher.service.ts</path>
      <key-methods>
        - publish(type, data, context): Publishes single event
        - publishBatch(events): Publishes multiple events atomically
      </key-methods>
      <event-format>
        Events stored as JSON in Redis stream field 'event'
        Structure: BaseEvent with id, type, data, tenantId, userId, etc.
      </event-format>
    </file>

    <file>
      <path>packages/shared/src/types/events.ts</path>
      <key-exports>
        - BaseEvent interface
        - EventTypes constant (all event type names)
        - EventType union type
        - Typed payload interfaces (ApprovalDecisionPayload, etc.)
      </key-exports>
    </file>

    <file>
      <path>apps/api/src/events/events.module.ts</path>
      <current-state>
        - Registers RedisProvider and EventPublisherService
        - Sets up consumer groups in onModuleInit
        - Imports BullModule for event-retry queue
      </current-state>
      <needs-modification>
        - Import DiscoveryModule from @nestjs/core
        - Add EventConsumerService to providers
      </needs-modification>
    </file>
  </existing-code-reference>

  <acceptance-criteria>
    <criterion id="AC1">
      <description>@EventSubscriber() decorator created that registers methods as event handlers</description>
      <verification>Decorator stores pattern, priority, maxRetries in metadata</verification>
    </criterion>

    <criterion id="AC2">
      <description>EventConsumerService reads from Redis Stream in consumer group (hyvve-platform)</description>
      <verification>XREADGROUP called with correct parameters (GROUP, consumer name, COUNT, BLOCK, STREAMS)</verification>
    </criterion>

    <criterion id="AC3">
      <description>Events dispatched to matching handlers by pattern (exact match and wildcards)</description>
      <verification>findMatchingHandlers returns correct handlers for event type</verification>
    </criterion>

    <criterion id="AC4">
      <description>Wildcard patterns supported (e.g., approval.* matches all approval events)</description>
      <verification>Pattern matching logic handles *, prefix.*, and exact matches</verification>
    </criterion>

    <criterion id="AC5">
      <description>Events acknowledged (XACK) after successful processing</description>
      <verification>XACK called with streamId after handler execution</verification>
    </criterion>

    <criterion id="AC6">
      <description>Handler priority ordering works (lower priority number = higher priority)</description>
      <verification>Handlers executed in ascending priority order</verification>
    </criterion>

    <criterion id="AC7">
      <description>Multiple handlers can subscribe to the same event</description>
      <verification>All matching handlers called for single event</verification>
    </criterion>

    <criterion id="AC8">
      <description>Consumer service discovers handlers via NestJS DiscoveryService</description>
      <verification>discoverHandlers() uses DiscoveryService and Reflector to find decorated methods</verification>
    </criterion>

    <criterion id="AC9">
      <description>Consumer loop runs continuously with blocking reads (XREADGROUP)</description>
      <verification>consumeLoop() uses while(running) with XREADGROUP BLOCK</verification>
    </criterion>

    <criterion id="AC10">
      <description>Graceful shutdown on module destroy (stop consuming, finish pending events)</description>
      <verification>onModuleDestroy sets running=false and waits for batch to complete</verification>
    </criterion>
  </acceptance-criteria>

  <related-documentation>
    <document>
      <path>docs/archive/foundation-phase/sprint-artifacts/tech-spec-epic-05.md</path>
      <section>Story 05.3: Implement Event Subscriber</section>
      <relevance>Complete technical specification with code examples</relevance>
    </document>

    <document>
      <path>docs/epics/EPIC-05-event-bus.md</path>
      <relevance>Epic overview and requirements</relevance>
    </document>

    <document>
      <path>docs/architecture.md</path>
      <section>Cross-Module Communication</section>
      <relevance>Event bus architecture and patterns</relevance>
    </document>

    <document>
      <path>packages/shared/src/types/events.ts</path>
      <relevance>Event type definitions and payload interfaces</relevance>
    </document>

    <document>
      <path>docs/archive/foundation-phase/sprint-artifacts/stories/05-1-set-up-redis-streams-infrastructure.md</path>
      <relevance>Redis Streams setup and consumer group creation</relevance>
    </document>

    <document>
      <path>docs/archive/foundation-phase/sprint-artifacts/stories/05-2-implement-event-publisher.md</path>
      <relevance>Event publishing and serialization format</relevance>
    </document>
  </related-documentation>

  <notes>
    <note>
      This story implements the consumer side only. Retry logic (handleError) will be a placeholder that logs errors until Story 05-4 implements EventRetryService.
    </note>

    <note>
      Each app instance gets a unique consumer name (hostname or PID) but shares the same consumer group. This allows horizontal scaling - events are distributed across instances automatically by Redis.
    </note>

    <note>
      Handlers are discovered dynamically at startup. No manual registration needed. Any service with @EventSubscriber decorated methods will be found automatically.
    </note>

    <note>
      Consumer starts automatically when EventsModule initializes. No explicit start() call needed.
    </note>

    <note>
      Event handlers can be in any module as long as the module is imported into the app. EventConsumerService discovers handlers across the entire application.
    </note>

    <note>
      Pattern matching is case-sensitive. Event types follow kebab-case convention (e.g., approval.item.approved).
    </note>

    <note>
      Handlers receive the full BaseEvent object, including metadata (tenantId, userId, correlationId). Handlers should type-cast event.data to the expected payload type.
    </note>
  </notes>
</story-context>
