<?xml version="1.0" encoding="UTF-8"?>
<story-context>
  <story>
    <id>10.1</id>
    <title>Redis Rate Limiting Migration</title>
    <epic>EPIC-10 - Platform Hardening</epic>
    <status>ready-for-dev</status>
    <points>3</points>
    <priority>P0 Critical</priority>
  </story>

  <summary>
    This story focuses on configuring and verifying Redis-based distributed rate limiting
    using Upstash. The implementation is ALREADY COMPLETE - the unified rate limiter at
    apps/web/src/lib/utils/rate-limit.ts already uses @upstash/ratelimit with proper
    fallback to in-memory when Redis is not configured. This story is primarily about:
    1. Documenting Upstash configuration in deployment guide
    2. Adding environment variables to .env.example
    3. Testing rate limit persistence in staging
    4. Verifying the existing implementation works as expected
  </summary>

  <key-findings>
    <finding type="already-implemented">
      ✅ @upstash/ratelimit package is already installed (version 2.0.7)
    </finding>
    <finding type="already-implemented">
      ✅ @upstash/redis package is already installed (version 1.35.7)
    </finding>
    <finding type="already-implemented">
      ✅ Unified rate limiter implemented at apps/web/src/lib/utils/rate-limit.ts
    </finding>
    <finding type="already-implemented">
      ✅ Redis fallback mechanism properly implemented
    </finding>
    <finding type="already-implemented">
      ✅ Pre-configured helper functions exist: checkTwoFactorRateLimit, checkLoginRateLimit, etc.
    </finding>
    <finding type="already-implemented">
      ✅ verify-login route already uses unified rate limiter
    </finding>
    <finding type="needs-implementation">
      ❌ UPSTASH_REDIS_REST_URL and UPSTASH_REDIS_REST_TOKEN not in .env.example
    </finding>
    <finding type="needs-implementation">
      ❌ Upstash Redis setup not documented in DEPLOYMENT.md
    </finding>
    <finding type="verification-needed">
      ⚠️ Need to test rate limit persistence across server restarts in staging
    </finding>
  </key-findings>

  <current-implementation>
    <file path="apps/web/src/lib/utils/rate-limit.ts">
/**
 * Unified Rate Limiter with Redis (Upstash) and In-Memory Fallback
 *
 * Production: Uses Upstash Redis for distributed rate limiting across instances
 * Development: Falls back to in-memory Map when Redis is not configured
 *
 * Environment Variables:
 * - UPSTASH_REDIS_REST_URL: Upstash Redis REST API URL
 * - UPSTASH_REDIS_REST_TOKEN: Upstash Redis REST API token
 *
 * @module rate-limit
 */

import { Redis } from '@upstash/redis'
import { Ratelimit } from '@upstash/ratelimit'

// ============================================================================
// Configuration Constants
// ============================================================================

/** Maximum entries in in-memory fallback (prevents unbounded growth) */
export const RATE_LIMIT_MAX_ENTRIES = 10000

/** Default rate limit window in seconds */
export const DEFAULT_RATE_LIMIT_WINDOW_SECONDS = 900 // 15 minutes

/** Default maximum attempts per window */
export const DEFAULT_RATE_LIMIT_MAX_ATTEMPTS = 5

// ============================================================================
// Types
// ============================================================================

interface RateLimitEntry {
  count: number
  resetAt: number // Unix timestamp in milliseconds
}

interface RateLimitResult {
  isRateLimited: boolean
  remaining: number
  resetAt: Date
  retryAfter?: number // Seconds until reset
}

interface RateLimitConfig {
  /** Maximum number of attempts allowed in the window */
  limit: number
  /** Time window in seconds */
  windowSeconds: number
}

// ============================================================================
// Redis Client Initialization
// ============================================================================

let redis: Redis | null = null
let isRedisConfigured = false

// Check if Redis is configured at module load
if (process.env.UPSTASH_REDIS_REST_URL && process.env.UPSTASH_REDIS_REST_TOKEN) {
  try {
    redis = new Redis({
      url: process.env.UPSTASH_REDIS_REST_URL,
      token: process.env.UPSTASH_REDIS_REST_TOKEN,
    })
    isRedisConfigured = true
    console.log('[rate-limit] Redis configured - using distributed rate limiting')
  } catch (error) {
    console.warn('[rate-limit] Failed to initialize Redis, falling back to in-memory:', error)
    redis = null
    isRedisConfigured = false
  }
} else {
  console.log('[rate-limit] Redis not configured - using in-memory rate limiting (NOT production-ready)')
}

// ============================================================================
// Upstash Ratelimit Cache
// ============================================================================

const ratelimitCache = new Map&lt;string, Ratelimit&gt;()

/**
 * Get or create an Upstash Ratelimit instance for the given config
 */
function getRatelimiter(config: RateLimitConfig): Ratelimit | null {
  if (!redis) return null

  const cacheKey = `${config.limit}:${config.windowSeconds}`
  let limiter = ratelimitCache.get(cacheKey)

  if (!limiter) {
    limiter = new Ratelimit({
      redis,
      limiter: Ratelimit.slidingWindow(config.limit, `${config.windowSeconds} s`),
      analytics: true,
      prefix: 'hyvve:ratelimit',
    })
    ratelimitCache.set(cacheKey, limiter)
  }

  return limiter
}

// ============================================================================
// In-Memory Fallback Storage
// ============================================================================

const rateLimitStore = new Map&lt;string, RateLimitEntry&gt;()

/**
 * Clean up expired entries and enforce max entries limit
 * @internal
 */
function cleanupRateLimits(): void {
  const now = Date.now()

  // Remove expired entries
  for (const [key, entry] of rateLimitStore.entries()) {
    if (entry.resetAt &lt; now) {
      rateLimitStore.delete(key)
    }
  }

  // Enforce max entries if still over limit
  if (rateLimitStore.size &gt; RATE_LIMIT_MAX_ENTRIES) {
    const entries = Array.from(rateLimitStore.entries())
    entries.sort((a, b) =&gt; a[1].resetAt - b[1].resetAt) // Oldest first
    const toRemove = entries.slice(0, rateLimitStore.size - RATE_LIMIT_MAX_ENTRIES)
    for (const [key] of toRemove) {
      rateLimitStore.delete(key)
    }
  }
}

// Clean up expired entries periodically (every 5 minutes)
// Only start the interval if we're in a long-running process (not serverless)
if (typeof setInterval !== 'undefined' && !isRedisConfigured) {
  setInterval(cleanupRateLimits, 5 * 60 * 1000)
}

/**
 * In-memory rate limit check (fallback when Redis not available)
 * @internal
 */
function checkRateLimitInMemory(
  key: string,
  limit: number,
  windowSeconds: number
): RateLimitResult {
  const now = Date.now()
  const windowMs = windowSeconds * 1000

  let entry = rateLimitStore.get(key)

  // If entry doesn't exist or window has expired, create new entry
  if (!entry || entry.resetAt &lt; now) {
    // Ensure capacity before adding new entry
    if (rateLimitStore.size &gt;= RATE_LIMIT_MAX_ENTRIES && !rateLimitStore.has(key)) {
      cleanupRateLimits()
    }
    entry = {
      count: 0,
      resetAt: now + windowMs,
    }
    rateLimitStore.set(key, entry)
  }

  // Increment count
  entry.count++

  const remaining = Math.max(0, limit - entry.count)
  const isRateLimited = entry.count &gt; limit
  const retryAfter = isRateLimited
    ? Math.ceil((entry.resetAt - now) / 1000)
    : undefined

  return {
    isRateLimited,
    remaining,
    resetAt: new Date(entry.resetAt),
    retryAfter,
  }
}

// ============================================================================
// Public API
// ============================================================================

/**
 * Check if a rate limit key has exceeded the limit
 *
 * Uses Redis when configured, falls back to in-memory for development.
 *
 * @param key - Unique identifier for rate limiting (e.g., `2fa:user@example.com`)
 * @param limit - Maximum number of attempts allowed (default: 5)
 * @param windowSeconds - Time window in seconds (default: 900 = 15 minutes)
 * @returns Object with whether rate limited and retry information
 *
 * @example
 * ```typescript
 * const result = await checkRateLimit(`2fa:${userId}`, 5, 900)
 * if (result.isRateLimited) {
 *   return NextResponse.json(
 *     { error: 'Too many attempts', retryAfter: result.retryAfter },
 *     { status: 429 }
 *   )
 * }
 * ```
 */
export async function checkRateLimit(
  key: string,
  limit: number = DEFAULT_RATE_LIMIT_MAX_ATTEMPTS,
  windowSeconds: number = DEFAULT_RATE_LIMIT_WINDOW_SECONDS
): Promise&lt;RateLimitResult&gt; {
  // Try Redis first if configured
  const limiter = getRatelimiter({ limit, windowSeconds })

  if (limiter) {
    try {
      const result = await limiter.limit(key)

      return {
        isRateLimited: !result.success,
        remaining: result.remaining,
        resetAt: new Date(result.reset),
        retryAfter: result.success ? undefined : Math.ceil((result.reset - Date.now()) / 1000),
      }
    } catch (error) {
      console.warn('[rate-limit] Redis error, falling back to in-memory:', error)
      // Fall through to in-memory
    }
  }

  // In-memory fallback
  return checkRateLimitInMemory(key, limit, windowSeconds)
}

/**
 * Synchronous rate limit check (in-memory only)
 *
 * Use this when you cannot use async/await (e.g., in some middleware).
 * Note: This bypasses Redis and only uses in-memory storage.
 *
 * @param key - Unique identifier for rate limiting
 * @param limit - Maximum number of attempts allowed
 * @param windowSeconds - Time window in seconds
 * @returns Object with whether rate limited and retry information
 *
 * @deprecated Prefer async `checkRateLimit` for production use
 */
export function checkRateLimitSync(
  key: string,
  limit: number = DEFAULT_RATE_LIMIT_MAX_ATTEMPTS,
  windowSeconds: number = DEFAULT_RATE_LIMIT_WINDOW_SECONDS
): RateLimitResult {
  if (isRedisConfigured) {
    console.warn('[rate-limit] checkRateLimitSync called with Redis configured. Use async checkRateLimit instead.')
  }
  return checkRateLimitInMemory(key, limit, windowSeconds)
}

/**
 * Get current rate limit info without incrementing counter
 *
 * Note: Only works with in-memory storage. Redis rate limits cannot be queried
 * without modification due to how sliding window works.
 *
 * @param key - Rate limit key
 * @returns Current rate limit status
 */
export function getRateLimitInfo(key: string): {
  count: number
  resetAt: Date | null
  isRedisConfigured: boolean
} {
  const entry = rateLimitStore.get(key)

  if (!entry) {
    return {
      count: 0,
      resetAt: null,
      isRedisConfigured,
    }
  }

  const now = Date.now()
  if (entry.resetAt &lt; now) {
    rateLimitStore.delete(key)
    return {
      count: 0,
      resetAt: null,
      isRedisConfigured,
    }
  }

  return {
    count: entry.count,
    resetAt: new Date(entry.resetAt),
    isRedisConfigured,
  }
}

/**
 * Reset rate limit for a specific key
 *
 * Works for both in-memory and Redis storage.
 *
 * @param key - Rate limit key to reset
 */
export async function resetRateLimit(key: string): Promise&lt;void&gt; {
  // Clear in-memory
  rateLimitStore.delete(key)

  // Clear Redis if configured
  if (redis) {
    try {
      await redis.del(`hyvve:ratelimit:${key}`)
    } catch (error) {
      console.warn('[rate-limit] Failed to reset Redis rate limit:', error)
    }
  }
}

/**
 * Check if Redis is configured for distributed rate limiting
 * @returns true if Redis/Upstash is configured and available
 */
export function isDistributedRateLimitingEnabled(): boolean {
  return isRedisConfigured
}

// ============================================================================
// Pre-configured Rate Limiters for Common Use Cases
// ============================================================================

/**
 * Rate limit for 2FA verification attempts
 * 5 attempts per 15 minutes
 */
export async function checkTwoFactorRateLimit(identifier: string): Promise&lt;RateLimitResult&gt; {
  return checkRateLimit(`2fa:${identifier}`, 5, 900)
}

/**
 * Rate limit for password reset requests
 * 3 attempts per hour
 */
export async function checkPasswordResetRateLimit(identifier: string): Promise&lt;RateLimitResult&gt; {
  return checkRateLimit(`password-reset:${identifier}`, 3, 3600)
}

/**
 * Rate limit for email verification resends
 * 3 attempts per 5 minutes
 */
export async function checkEmailResendRateLimit(identifier: string): Promise&lt;RateLimitResult&gt; {
  return checkRateLimit(`email-resend:${identifier}`, 3, 300)
}

/**
 * Rate limit for login attempts
 * 10 attempts per 15 minutes
 */
export async function checkLoginRateLimit(identifier: string): Promise&lt;RateLimitResult&gt; {
  return checkRateLimit(`login:${identifier}`, 10, 900)
}

/**
 * Rate limit for API requests (general)
 * 100 requests per minute
 */
export async function checkApiRateLimit(identifier: string): Promise&lt;RateLimitResult&gt; {
  return checkRateLimit(`api:${identifier}`, 100, 60)
}
    </file>

    <file path="apps/web/src/app/api/auth/2fa/verify-login/route.ts">
/**
 * Two-Factor Authentication Verification API
 * Story 09-4: Verify TOTP/backup code during login and optionally trust device
 *
 * POST /api/auth/2fa/verify-login
 *
 * SECURITY:
 * - Rate limiting: 5 attempts per 15 minutes (Redis in production)
 * - Backup codes are hashed with bcrypt
 * - Trusted device tokens are hashed with SHA-256
 * - Device fingerprint verified on trusted device use
 */

import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@hyvve/db'
import { verifyTOTPCode, verifyBackupCode, decryptSecret } from '@/lib/two-factor'
import { checkTwoFactorRateLimit, resetRateLimit } from '@/lib/utils/rate-limit'
import {
  createTrustedDevice,
  setTrustedDeviceCookie,
} from '@/lib/trusted-device'

interface VerifyLoginRequest {
  userId: string
  code: string
  isBackupCode?: boolean
  trustDevice?: boolean
}

export async function POST(request: NextRequest) {
  try {
    const body: VerifyLoginRequest = await request.json()
    const { userId, code, isBackupCode = false, trustDevice = false } = body

    // Validate input
    if (!userId || !code) {
      return NextResponse.json(
        { error: { code: 'INVALID_INPUT', message: 'User ID and code are required' } },
        { status: 400 }
      )
    }

    // Check rate limiting using unified rate limiter (Redis in production, in-memory fallback)
    const rateLimitResult = await checkTwoFactorRateLimit(userId)
    if (rateLimitResult.isRateLimited) {
      const remainingTime = Math.ceil((rateLimitResult.retryAfter || 0) / 60)
      return NextResponse.json(
        {
          error: {
            code: 'RATE_LIMITED',
            message: `Too many attempts. Try again in ${remainingTime} minutes.`,
          },
          remainingAttempts: 0,
        },
        { status: 429 }
      )
    }

    // Get user with 2FA data
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: {
        id: true,
        email: true,
        name: true,
        twoFactorEnabled: true,
        twoFactorSecret: true,
      },
    })

    if (!user || !user.twoFactorEnabled) {
      return NextResponse.json(
        { error: { code: 'NOT_FOUND', message: '2FA not enabled for this user' } },
        { status: 404 }
      )
    }

    let isValid = false

    if (isBackupCode) {
      // Verify backup code using serializable transaction to prevent race conditions
      // This ensures atomicity between verification and mark-as-used
      isValid = await prisma.$transaction(
        async (tx) =&gt; {
          // Fetch backup codes within the transaction
          const backupCodes = await tx.backupCode.findMany({
            where: {
              userId,
              used: false,
            },
          })

          for (const backupCode of backupCodes) {
            if (await verifyBackupCode(code.toUpperCase(), backupCode.code)) {
              // Atomic mark-as-used with optimistic lock check
              // Even within transaction, check used: false to handle edge cases
              const updated = await tx.backupCode.updateMany({
                where: { id: backupCode.id, used: false },
                data: {
                  used: true,
                  usedAt: new Date(),
                },
              })
              // Only valid if we successfully marked it as used
              return updated.count &gt; 0
            }
          }
          return false
        },
        {
          // Use serializable isolation to prevent concurrent reads of same unused codes
          isolationLevel: 'Serializable',
          timeout: 10000, // 10 second timeout for bcrypt operations
        }
      )
    } else {
      // Verify TOTP code
      if (!user.twoFactorSecret) {
        return NextResponse.json(
          { error: { code: 'INVALID_SETUP', message: '2FA secret not found' } },
          { status: 400 }
        )
      }

      const masterKey = process.env.BETTER_AUTH_SECRET
      if (!masterKey) {
        return NextResponse.json(
          { error: { code: 'SERVER_ERROR', message: 'Encryption key not configured' } },
          { status: 500 }
        )
      }
      const decryptedSecret = await decryptSecret(user.twoFactorSecret, masterKey)
      isValid = verifyTOTPCode(decryptedSecret, code)
    }

    if (!isValid) {
      // Rate limit was already incremented by checkTwoFactorRateLimit above
      // Just return error with remaining attempts from the rate limit result
      return NextResponse.json(
        {
          error: {
            code: 'INVALID_CODE',
            message: 'Invalid or expired code',
          },
          remainingAttempts: rateLimitResult.remaining,
        },
        { status: 400 }
      )
    }

    // Clear rate limit on success
    await resetRateLimit(`2fa:${userId}`)

    // Create response
    const response = NextResponse.json({ success: true })

    // Create trusted device if requested
    if (trustDevice) {
      const trustedDeviceResult = await createTrustedDevice(request, userId)

      if (trustedDeviceResult.success && trustedDeviceResult.token) {
        setTrustedDeviceCookie(response, trustedDeviceResult.token)
      }
      // If trusted device creation fails, we still return success for 2FA
      // Just without the trusted device cookie
    }

    return response
  } catch (error) {
    console.error('2FA verification error:', error)
    return NextResponse.json(
      { error: { code: 'INTERNAL_ERROR', message: 'Failed to verify code' } },
      { status: 500 }
    )
  }
}
    </file>
  </current-implementation>

  <configuration>
    <file path="apps/web/package.json">
{
  "dependencies": {
    "@upstash/ratelimit": "^2.0.7",
    "@upstash/redis": "^1.35.7",
    // ... other dependencies
  }
}
    </file>

    <file path=".env.example" note="Root .env.example - NEEDS UPDATE">
# ============================================
# REDIS (Story 00.5)
# ============================================
REDIS_URL="redis://localhost:6379"

# MISSING: UPSTASH_REDIS_REST_URL and UPSTASH_REDIS_REST_TOKEN
# These need to be added for distributed rate limiting
    </file>
  </configuration>

  <existing-documentation>
    <file path="docs/DEPLOYMENT.md" section="Redis Configuration">
## Redis Configuration

### Production Redis Requirements

- **TLS:** Always use `rediss://` protocol in production
- **Authentication:** Require password
- **Persistence:** Enable AOF or RDB for queue durability

### Upstash Configuration (Recommended)

```bash
REDIS_URL="rediss://default:password@your-endpoint.upstash.io:6379"
```

### Rate Limiting Migration

**Important:** The default in-memory rate limiter is NOT production-ready. Migrate to Redis:

```typescript
// Use Redis-based rate limiting in production
// See: apps/web/src/lib/utils/rate-limit.ts
```

### Redis Streams for Event Bus

The event bus uses Redis Streams. Ensure your Redis instance:
- Has sufficient memory for stream data
- Has persistence enabled (data survives restarts)
- Is in the same region as your application
    </file>
  </existing-documentation>

  <tech-spec-guidance>
    <section title="Story 10.1: Redis Rate Limiting Migration">
**Priority:** P0 Critical
**Points:** 3
**Dependencies:** None (can start immediately)

#### Current Implementation Analysis

The codebase already has a unified rate limiter at `apps/web/src/lib/utils/rate-limit.ts` that:
- ✅ Uses `@upstash/ratelimit` package
- ✅ Checks for `UPSTASH_REDIS_REST_URL` and `UPSTASH_REDIS_REST_TOKEN` at module load
- ✅ Falls back to in-memory Map when Redis unavailable
- ✅ Provides helper functions: `checkTwoFactorRateLimit`, `checkLoginRateLimit`, etc.
- ✅ Already used in `verify-login/route.ts`

**Current Code Quality:** Good implementation with proper fallback mechanism.

#### Implementation Approach

1. **Verify Upstash Configuration**
   - Add environment variables to `.env.example`
   - Document Upstash setup in `docs/DEPLOYMENT.md`
   - Verify Redis client initialization

2. **Test in Development**
   - Set up local Upstash Redis instance or use Upstash free tier
   - Verify rate limits persist across server restarts
   - Test fallback behavior when Redis unavailable

3. **Consolidate Duplicate Implementations**
   - The code is already consolidated in single file
   - Remove any duplicate rate limiter references if found

4. **Verify Production Readiness**
   - Test in staging environment
   - Verify rate limit persistence
   - Confirm serverless compatibility

#### Configuration

```bash
# .env.example additions
UPSTASH_REDIS_REST_URL=https://your-redis.upstash.io
UPSTASH_REDIS_REST_TOKEN=your-token
```

#### Code Patterns

The existing implementation is solid. Key patterns to preserve:

```typescript
// Fallback mechanism
if (process.env.UPSTASH_REDIS_REST_URL && process.env.UPSTASH_REDIS_REST_TOKEN) {
  redis = new Redis({
    url: process.env.UPSTASH_REDIS_REST_URL,
    token: process.env.UPSTASH_REDIS_REST_TOKEN,
  })
  isRedisConfigured = true
}

// Try Redis first, fall back to in-memory
const limiter = getRatelimiter({ limit, windowSeconds })
if (limiter) {
  try {
    const result = await limiter.limit(key)
    return { isRateLimited: !result.success, ... }
  } catch (error) {
    console.warn('[rate-limit] Redis error, falling back to in-memory:', error)
  }
}
return checkRateLimitInMemory(key, limit, windowSeconds)
```
    </section>
  </tech-spec-guidance>

  <implementation-notes>
    <note priority="high">
      The rate limiting implementation is ALREADY COMPLETE. This story is primarily
      about configuration, documentation, and testing. No code changes needed to
      the core rate limiter.
    </note>

    <note priority="high">
      Need to add UPSTASH_REDIS_REST_URL and UPSTASH_REDIS_REST_TOKEN to .env.example
      with clear instructions on how to obtain these from Upstash.
    </note>

    <note priority="medium">
      Need to expand docs/DEPLOYMENT.md Redis section with specific Upstash setup
      instructions including:
      1. Creating Upstash account
      2. Creating Redis database
      3. Obtaining REST URL and token
      4. Configuring environment variables
      5. Testing connection
    </note>

    <note priority="medium">
      The verify-login route is already using the unified rate limiter via
      checkTwoFactorRateLimit(). No route updates needed.
    </note>

    <note priority="low">
      The implementation uses Upstash Redis REST API (not Redis protocol), which
      is specifically designed for serverless and edge deployments. This is perfect
      for Next.js serverless functions.
    </note>

    <note priority="low">
      Rate limit configurations are defined:
      - 2FA: 5 attempts / 15 minutes
      - Login: 10 attempts / 15 minutes
      - Password reset: 3 attempts / hour
      - Email resend: 3 attempts / 5 minutes
      - API: 100 requests / minute
    </note>
  </implementation-notes>

  <acceptance-criteria>
    <criterion id="AC1" status="complete">
      Install @upstash/ratelimit package
      - ✅ Already installed: "@upstash/ratelimit": "^2.0.7"
    </criterion>

    <criterion id="AC2" status="complete">
      Create Redis rate limiter utility in apps/web/src/lib/utils/rate-limit-redis.ts
      - ✅ Already exists at apps/web/src/lib/utils/rate-limit.ts (unified implementation)
    </criterion>

    <criterion id="AC3" status="needs-implementation">
      Configure Upstash Redis connection via UPSTASH_REDIS_REST_URL and UPSTASH_REDIS_REST_TOKEN
      - ❌ Need to add these to .env.example
      - ✅ Code already checks for these environment variables
    </criterion>

    <criterion id="AC4" status="complete">
      Replace in-memory rate limiter in apps/web/src/app/api/auth/2fa/verify-login/route.ts
      - ✅ Already uses unified rate limiter via checkTwoFactorRateLimit()
    </criterion>

    <criterion id="AC5" status="complete">
      Replace duplicate rate limiter in apps/web/src/lib/utils/rate-limit.ts
      - ✅ No duplicate - single unified implementation exists
    </criterion>

    <criterion id="AC6" status="complete">
      Add fallback to in-memory for local development when Redis unavailable
      - ✅ Fallback mechanism fully implemented with checkRateLimitInMemory()
    </criterion>

    <criterion id="AC7" status="needs-verification">
      Rate limits persist across server restarts (verified in staging)
      - ⚠️ Needs testing in staging environment with actual Upstash Redis
    </criterion>

    <criterion id="AC8" status="needs-implementation">
      Update docs/DEPLOYMENT.md with Upstash configuration
      - ❌ Need to add detailed Upstash setup section
    </criterion>
  </acceptance-criteria>

  <testing-requirements>
    <unit-tests status="complete">
      Unit tests for rate limit functionality already exist
    </unit-tests>

    <integration-tests status="needs-implementation">
      - Test Redis connectivity with valid credentials
      - Test fallback to in-memory when Redis unavailable
      - Test rate limit persistence across server restarts
      - Load test to verify distributed rate limiting works across multiple instances
    </integration-tests>

    <manual-tests status="needs-execution">
      1. Configure Upstash Redis in staging environment
      2. Make 5 2FA attempts to trigger rate limit
      3. Restart server
      4. Verify rate limit is still in effect (6th attempt should fail)
      5. Wait for window to expire
      6. Verify rate limit resets
    </manual-tests>
  </testing-requirements>

  <files-to-modify>
    <file action="update" path=".env.example">
      Add UPSTASH_REDIS_REST_URL and UPSTASH_REDIS_REST_TOKEN with documentation
    </file>

    <file action="update" path="docs/DEPLOYMENT.md">
      Expand Redis Configuration section with detailed Upstash setup instructions
    </file>

    <file action="verify" path="apps/web/src/lib/utils/rate-limit.ts">
      Verify implementation is correct (no changes needed)
    </file>

    <file action="verify" path="apps/web/src/app/api/auth/2fa/verify-login/route.ts">
      Verify it uses unified rate limiter (no changes needed)
    </file>
  </files-to-modify>

  <dependencies>
    <dependency type="none">
      This story has no dependencies and can start immediately
    </dependency>
  </dependencies>

  <related-stories>
    <story id="10.8">
      Backup Code Race Condition Fix - Both stories involve transaction handling
      and rate limiting
    </story>
  </related-stories>
</story-context>
