# HYVVE E2E Test Suite

Production-ready Playwright test framework for HYVVE platform.

## Setup

### Prerequisites

- Node.js >= 20.0.0
- pnpm >= 9.0.0
- Docker (for test database)

### Installation

```bash
# Install Playwright and browsers
cd apps/web
pnpm add -D @playwright/test @faker-js/faker
pnpm exec playwright install
```

### Environment Configuration

```bash
# Copy environment template
cp tests/.env.example tests/.env.local

# Fill in test credentials
# For OAuth E2E (Story 14.18), set:
# E2E_OAUTH_TEST=true
# BASE_URL=http://localhost:3000
# TEST_USER_EMAIL/TEST_USER_PASSWORD (used for seeded login helpers)
# OAuth client IDs/secrets can remain dummy when E2E_OAUTH_TEST is true
```

## Running Tests

```bash
# Run all tests
pnpm test:e2e

# Run in headed mode (see browser)
pnpm test:e2e -- --headed

# Run in UI mode (interactive)
pnpm test:e2e -- --ui

# Run specific test file
pnpm test:e2e -- tests/e2e/auth.spec.ts

# Run with debug mode
pnpm test:e2e -- --debug

# View HTML report
pnpm exec playwright show-report test-results/html
```

## Test Architecture

### Directory Structure

```
tests/
├── e2e/                    # E2E test specs
│   ├── auth.spec.ts        # Authentication flows
│   ├── smoke.spec.ts       # Basic sanity checks
│   └── [feature].spec.ts   # Feature-specific tests
├── support/                # Test infrastructure
│   ├── fixtures/           # Playwright fixtures
│   │   ├── index.ts        # Merged fixture exports
│   │   └── factories/      # Data factories
│   ├── helpers/            # Pure utility functions
│   └── page-objects/       # Page object models (optional)
├── .env.example            # Environment template
└── README.md               # This file
```

### Fixture Pattern

We use composable fixtures instead of inheritance-based Page Object Models:

```typescript
import { test, expect } from '../support/fixtures';

test('user can login', async ({ page, auth, userFactory }) => {
  // Create test user (auto-cleaned after test)
  const user = await userFactory.createVerifiedUser();

  // Use auth fixture for login
  await auth.loginAs(user.email, user.password);

  // Assert
  await expect(page.locator('[data-testid="user-menu"]')).toBeVisible();
});
```

### Data Factories

Factories create test data via API and auto-cleanup after each test:

- `UserFactory` - Create users for authentication tests
- `WorkspaceFactory` - Create workspaces for multi-tenant tests

```typescript
const user = await userFactory.createUser({ name: 'Custom Name' });
const verifiedUser = await userFactory.createVerifiedUser();
// Cleanup happens automatically
```

## Test Selectors

Use `data-testid` attributes for robust selectors:

```tsx
// Component
<button data-testid="sign-in-button">Sign In</button>

// Test
await page.click('[data-testid="sign-in-button"]');
```

## Debugging

### Trace Viewer

Failed tests automatically capture traces:

```bash
pnpm exec playwright show-trace test-results/trace.zip
```

### Screenshots & Videos

Configured for failure-only capture (saves storage):

- Screenshots: `test-results/**/*.png`
- Videos: `test-results/**/*.webm`

## CI Integration

Tests run in CI with:
- Single worker (sequential execution)
- 2 retries on failure
- JUnit XML report for CI dashboards

## Best Practices

1. **Test Isolation**: Each test creates its own data via factories
2. **Auto-Cleanup**: Fixtures clean up data automatically
3. **Network-First**: Intercept APIs before navigation when mocking
4. **Deterministic Waits**: Avoid `sleep()`, use explicit waits
5. **Failure Artifacts**: Use traces to debug failures

## Knowledge Base

TEA (Test Expert Architect) knowledge base:
- `fixture-architecture.md` - Composable fixture patterns
- `data-factories.md` - Test data management
- `network-first.md` - Network interception strategies
- `test-quality.md` - Test design principles

---

Generated by TEA Agent (*framework workflow)
